<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>

<title>Matrices and Arrays</title>

<script type="text/javascript">
window.onload = function() {
  var imgs = document.getElementsByTagName('img'), i, img;
  for (i = 0; i < imgs.length; i++) {
    img = imgs[i];
    // center an image if it is the only element of its parent
    if (img.parentElement.childElementCount === 1)
      img.parentElement.style.textAlign = 'center';
  }
};
</script>

<!-- Styles for R syntax highlighter -->
<style type="text/css">
   pre .operator,
   pre .paren {
     color: rgb(104, 118, 135)
   }

   pre .literal {
     color: #990073
   }

   pre .number {
     color: #099;
   }

   pre .comment {
     color: #998;
     font-style: italic
   }

   pre .keyword {
     color: #900;
     font-weight: bold
   }

   pre .identifier {
     color: rgb(0, 0, 0);
   }

   pre .string {
     color: #d14;
   }
</style>

<!-- R syntax highlighter -->
<script type="text/javascript">
var hljs=new function(){function m(p){return p.replace(/&/gm,"&amp;").replace(/</gm,"&lt;")}function f(r,q,p){return RegExp(q,"m"+(r.cI?"i":"")+(p?"g":""))}function b(r){for(var p=0;p<r.childNodes.length;p++){var q=r.childNodes[p];if(q.nodeName=="CODE"){return q}if(!(q.nodeType==3&&q.nodeValue.match(/\s+/))){break}}}function h(t,s){var p="";for(var r=0;r<t.childNodes.length;r++){if(t.childNodes[r].nodeType==3){var q=t.childNodes[r].nodeValue;if(s){q=q.replace(/\n/g,"")}p+=q}else{if(t.childNodes[r].nodeName=="BR"){p+="\n"}else{p+=h(t.childNodes[r])}}}if(/MSIE [678]/.test(navigator.userAgent)){p=p.replace(/\r/g,"\n")}return p}function a(s){var r=s.className.split(/\s+/);r=r.concat(s.parentNode.className.split(/\s+/));for(var q=0;q<r.length;q++){var p=r[q].replace(/^language-/,"");if(e[p]){return p}}}function c(q){var p=[];(function(s,t){for(var r=0;r<s.childNodes.length;r++){if(s.childNodes[r].nodeType==3){t+=s.childNodes[r].nodeValue.length}else{if(s.childNodes[r].nodeName=="BR"){t+=1}else{if(s.childNodes[r].nodeType==1){p.push({event:"start",offset:t,node:s.childNodes[r]});t=arguments.callee(s.childNodes[r],t);p.push({event:"stop",offset:t,node:s.childNodes[r]})}}}}return t})(q,0);return p}function k(y,w,x){var q=0;var z="";var s=[];function u(){if(y.length&&w.length){if(y[0].offset!=w[0].offset){return(y[0].offset<w[0].offset)?y:w}else{return w[0].event=="start"?y:w}}else{return y.length?y:w}}function t(D){var A="<"+D.nodeName.toLowerCase();for(var B=0;B<D.attributes.length;B++){var C=D.attributes[B];A+=" "+C.nodeName.toLowerCase();if(C.value!==undefined&&C.value!==false&&C.value!==null){A+='="'+m(C.value)+'"'}}return A+">"}while(y.length||w.length){var v=u().splice(0,1)[0];z+=m(x.substr(q,v.offset-q));q=v.offset;if(v.event=="start"){z+=t(v.node);s.push(v.node)}else{if(v.event=="stop"){var p,r=s.length;do{r--;p=s[r];z+=("</"+p.nodeName.toLowerCase()+">")}while(p!=v.node);s.splice(r,1);while(r<s.length){z+=t(s[r]);r++}}}}return z+m(x.substr(q))}function j(){function q(x,y,v){if(x.compiled){return}var u;var s=[];if(x.k){x.lR=f(y,x.l||hljs.IR,true);for(var w in x.k){if(!x.k.hasOwnProperty(w)){continue}if(x.k[w] instanceof Object){u=x.k[w]}else{u=x.k;w="keyword"}for(var r in u){if(!u.hasOwnProperty(r)){continue}x.k[r]=[w,u[r]];s.push(r)}}}if(!v){if(x.bWK){x.b="\\b("+s.join("|")+")\\s"}x.bR=f(y,x.b?x.b:"\\B|\\b");if(!x.e&&!x.eW){x.e="\\B|\\b"}if(x.e){x.eR=f(y,x.e)}}if(x.i){x.iR=f(y,x.i)}if(x.r===undefined){x.r=1}if(!x.c){x.c=[]}x.compiled=true;for(var t=0;t<x.c.length;t++){if(x.c[t]=="self"){x.c[t]=x}q(x.c[t],y,false)}if(x.starts){q(x.starts,y,false)}}for(var p in e){if(!e.hasOwnProperty(p)){continue}q(e[p].dM,e[p],true)}}function d(B,C){if(!j.called){j();j.called=true}function q(r,M){for(var L=0;L<M.c.length;L++){if((M.c[L].bR.exec(r)||[null])[0]==r){return M.c[L]}}}function v(L,r){if(D[L].e&&D[L].eR.test(r)){return 1}if(D[L].eW){var M=v(L-1,r);return M?M+1:0}return 0}function w(r,L){return L.i&&L.iR.test(r)}function K(N,O){var M=[];for(var L=0;L<N.c.length;L++){M.push(N.c[L].b)}var r=D.length-1;do{if(D[r].e){M.push(D[r].e)}r--}while(D[r+1].eW);if(N.i){M.push(N.i)}return f(O,M.join("|"),true)}function p(M,L){var N=D[D.length-1];if(!N.t){N.t=K(N,E)}N.t.lastIndex=L;var r=N.t.exec(M);return r?[M.substr(L,r.index-L),r[0],false]:[M.substr(L),"",true]}function z(N,r){var L=E.cI?r[0].toLowerCase():r[0];var M=N.k[L];if(M&&M instanceof Array){return M}return false}function F(L,P){L=m(L);if(!P.k){return L}var r="";var O=0;P.lR.lastIndex=0;var M=P.lR.exec(L);while(M){r+=L.substr(O,M.index-O);var N=z(P,M);if(N){x+=N[1];r+='<span class="'+N[0]+'">'+M[0]+"</span>"}else{r+=M[0]}O=P.lR.lastIndex;M=P.lR.exec(L)}return r+L.substr(O,L.length-O)}function J(L,M){if(M.sL&&e[M.sL]){var r=d(M.sL,L);x+=r.keyword_count;return r.value}else{return F(L,M)}}function I(M,r){var L=M.cN?'<span class="'+M.cN+'">':"";if(M.rB){y+=L;M.buffer=""}else{if(M.eB){y+=m(r)+L;M.buffer=""}else{y+=L;M.buffer=r}}D.push(M);A+=M.r}function G(N,M,Q){var R=D[D.length-1];if(Q){y+=J(R.buffer+N,R);return false}var P=q(M,R);if(P){y+=J(R.buffer+N,R);I(P,M);return P.rB}var L=v(D.length-1,M);if(L){var O=R.cN?"</span>":"";if(R.rE){y+=J(R.buffer+N,R)+O}else{if(R.eE){y+=J(R.buffer+N,R)+O+m(M)}else{y+=J(R.buffer+N+M,R)+O}}while(L>1){O=D[D.length-2].cN?"</span>":"";y+=O;L--;D.length--}var r=D[D.length-1];D.length--;D[D.length-1].buffer="";if(r.starts){I(r.starts,"")}return R.rE}if(w(M,R)){throw"Illegal"}}var E=e[B];var D=[E.dM];var A=0;var x=0;var y="";try{var s,u=0;E.dM.buffer="";do{s=p(C,u);var t=G(s[0],s[1],s[2]);u+=s[0].length;if(!t){u+=s[1].length}}while(!s[2]);if(D.length>1){throw"Illegal"}return{r:A,keyword_count:x,value:y}}catch(H){if(H=="Illegal"){return{r:0,keyword_count:0,value:m(C)}}else{throw H}}}function g(t){var p={keyword_count:0,r:0,value:m(t)};var r=p;for(var q in e){if(!e.hasOwnProperty(q)){continue}var s=d(q,t);s.language=q;if(s.keyword_count+s.r>r.keyword_count+r.r){r=s}if(s.keyword_count+s.r>p.keyword_count+p.r){r=p;p=s}}if(r.language){p.second_best=r}return p}function i(r,q,p){if(q){r=r.replace(/^((<[^>]+>|\t)+)/gm,function(t,w,v,u){return w.replace(/\t/g,q)})}if(p){r=r.replace(/\n/g,"<br>")}return r}function n(t,w,r){var x=h(t,r);var v=a(t);var y,s;if(v){y=d(v,x)}else{return}var q=c(t);if(q.length){s=document.createElement("pre");s.innerHTML=y.value;y.value=k(q,c(s),x)}y.value=i(y.value,w,r);var u=t.className;if(!u.match("(\\s|^)(language-)?"+v+"(\\s|$)")){u=u?(u+" "+v):v}if(/MSIE [678]/.test(navigator.userAgent)&&t.tagName=="CODE"&&t.parentNode.tagName=="PRE"){s=t.parentNode;var p=document.createElement("div");p.innerHTML="<pre><code>"+y.value+"</code></pre>";t=p.firstChild.firstChild;p.firstChild.cN=s.cN;s.parentNode.replaceChild(p.firstChild,s)}else{t.innerHTML=y.value}t.className=u;t.result={language:v,kw:y.keyword_count,re:y.r};if(y.second_best){t.second_best={language:y.second_best.language,kw:y.second_best.keyword_count,re:y.second_best.r}}}function o(){if(o.called){return}o.called=true;var r=document.getElementsByTagName("pre");for(var p=0;p<r.length;p++){var q=b(r[p]);if(q){n(q,hljs.tabReplace)}}}function l(){if(window.addEventListener){window.addEventListener("DOMContentLoaded",o,false);window.addEventListener("load",o,false)}else{if(window.attachEvent){window.attachEvent("onload",o)}else{window.onload=o}}}var e={};this.LANGUAGES=e;this.highlight=d;this.highlightAuto=g;this.fixMarkup=i;this.highlightBlock=n;this.initHighlighting=o;this.initHighlightingOnLoad=l;this.IR="[a-zA-Z][a-zA-Z0-9_]*";this.UIR="[a-zA-Z_][a-zA-Z0-9_]*";this.NR="\\b\\d+(\\.\\d+)?";this.CNR="\\b(0[xX][a-fA-F0-9]+|(\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?)";this.BNR="\\b(0b[01]+)";this.RSR="!|!=|!==|%|%=|&|&&|&=|\\*|\\*=|\\+|\\+=|,|\\.|-|-=|/|/=|:|;|<|<<|<<=|<=|=|==|===|>|>=|>>|>>=|>>>|>>>=|\\?|\\[|\\{|\\(|\\^|\\^=|\\||\\|=|\\|\\||~";this.ER="(?![\\s\\S])";this.BE={b:"\\\\.",r:0};this.ASM={cN:"string",b:"'",e:"'",i:"\\n",c:[this.BE],r:0};this.QSM={cN:"string",b:'"',e:'"',i:"\\n",c:[this.BE],r:0};this.CLCM={cN:"comment",b:"//",e:"$"};this.CBLCLM={cN:"comment",b:"/\\*",e:"\\*/"};this.HCM={cN:"comment",b:"#",e:"$"};this.NM={cN:"number",b:this.NR,r:0};this.CNM={cN:"number",b:this.CNR,r:0};this.BNM={cN:"number",b:this.BNR,r:0};this.inherit=function(r,s){var p={};for(var q in r){p[q]=r[q]}if(s){for(var q in s){p[q]=s[q]}}return p}}();hljs.LANGUAGES.cpp=function(){var a={keyword:{"false":1,"int":1,"float":1,"while":1,"private":1,"char":1,"catch":1,"export":1,virtual:1,operator:2,sizeof:2,dynamic_cast:2,typedef:2,const_cast:2,"const":1,struct:1,"for":1,static_cast:2,union:1,namespace:1,unsigned:1,"long":1,"throw":1,"volatile":2,"static":1,"protected":1,bool:1,template:1,mutable:1,"if":1,"public":1,friend:2,"do":1,"return":1,"goto":1,auto:1,"void":2,"enum":1,"else":1,"break":1,"new":1,extern:1,using:1,"true":1,"class":1,asm:1,"case":1,typeid:1,"short":1,reinterpret_cast:2,"default":1,"double":1,register:1,explicit:1,signed:1,typename:1,"try":1,"this":1,"switch":1,"continue":1,wchar_t:1,inline:1,"delete":1,alignof:1,char16_t:1,char32_t:1,constexpr:1,decltype:1,noexcept:1,nullptr:1,static_assert:1,thread_local:1,restrict:1,_Bool:1,complex:1},built_in:{std:1,string:1,cin:1,cout:1,cerr:1,clog:1,stringstream:1,istringstream:1,ostringstream:1,auto_ptr:1,deque:1,list:1,queue:1,stack:1,vector:1,map:1,set:1,bitset:1,multiset:1,multimap:1,unordered_set:1,unordered_map:1,unordered_multiset:1,unordered_multimap:1,array:1,shared_ptr:1}};return{dM:{k:a,i:"</",c:[hljs.CLCM,hljs.CBLCLM,hljs.QSM,{cN:"string",b:"'\\\\?.",e:"'",i:"."},{cN:"number",b:"\\b(\\d+(\\.\\d*)?|\\.\\d+)(u|U|l|L|ul|UL|f|F)"},hljs.CNM,{cN:"preprocessor",b:"#",e:"$"},{cN:"stl_container",b:"\\b(deque|list|queue|stack|vector|map|set|bitset|multiset|multimap|unordered_map|unordered_set|unordered_multiset|unordered_multimap|array)\\s*<",e:">",k:a,r:10,c:["self"]}]}}}();hljs.LANGUAGES.r={dM:{c:[hljs.HCM,{cN:"number",b:"\\b0[xX][0-9a-fA-F]+[Li]?\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\b\\d+(?:[eE][+\\-]?\\d*)?L\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\b\\d+\\.(?!\\d)(?:i\\b)?",e:hljs.IMMEDIATE_RE,r:1},{cN:"number",b:"\\b\\d+(?:\\.\\d*)?(?:[eE][+\\-]?\\d*)?i?\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\.\\d+(?:[eE][+\\-]?\\d*)?i?\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"keyword",b:"(?:tryCatch|library|setGeneric|setGroupGeneric)\\b",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\.\\.\\.",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\.\\.\\d+(?![\\w.])",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\b(?:function)",e:hljs.IMMEDIATE_RE,r:2},{cN:"keyword",b:"(?:if|in|break|next|repeat|else|for|return|switch|while|try|stop|warning|require|attach|detach|source|setMethod|setClass)\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"literal",b:"(?:NA|NA_integer_|NA_real_|NA_character_|NA_complex_)\\b",e:hljs.IMMEDIATE_RE,r:10},{cN:"literal",b:"(?:NULL|TRUE|FALSE|T|F|Inf|NaN)\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"identifier",b:"[a-zA-Z.][a-zA-Z0-9._]*\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"operator",b:"<\\-(?!\\s*\\d)",e:hljs.IMMEDIATE_RE,r:2},{cN:"operator",b:"\\->|<\\-",e:hljs.IMMEDIATE_RE,r:1},{cN:"operator",b:"%%|~",e:hljs.IMMEDIATE_RE},{cN:"operator",b:">=|<=|==|!=|\\|\\||&&|=|\\+|\\-|\\*|/|\\^|>|<|!|&|\\||\\$|:",e:hljs.IMMEDIATE_RE,r:0},{cN:"operator",b:"%",e:"%",i:"\\n",r:1},{cN:"identifier",b:"`",e:"`",r:0},{cN:"string",b:'"',e:'"',c:[hljs.BE],r:0},{cN:"string",b:"'",e:"'",c:[hljs.BE],r:0},{cN:"paren",b:"[[({\\])}]",e:hljs.IMMEDIATE_RE,r:0}]}};
hljs.initHighlightingOnLoad();
</script>

<!-- MathJax scripts -->
<script type="text/javascript" src="https://cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML">
</script>


<style type="text/css">
body, td {
   font-family: sans-serif;
   background-color: white;
   font-size: 13px;
}

body {
  max-width: 800px;
  margin: auto;
  padding: 1em;
  line-height: 20px;
}

tt, code, pre {
   font-family: 'DejaVu Sans Mono', 'Droid Sans Mono', 'Lucida Console', Consolas, Monaco, monospace;
}

h1 {
   font-size:2.2em;
}

h2 {
   font-size:1.8em;
}

h3 {
   font-size:1.4em;
}

h4 {
   font-size:1.0em;
}

h5 {
   font-size:0.9em;
}

h6 {
   font-size:0.8em;
}

a:visited {
   color: rgb(50%, 0%, 50%);
}

pre, img {
  max-width: 100%;
}
pre {
  overflow-x: auto;
}
pre code {
   display: block; padding: 0.5em;
}

code {
  font-size: 92%;
  border: 1px solid #ccc;
}

code[class] {
  background-color: #F8F8F8;
}

table, td, th {
  border: none;
}

blockquote {
   color:#666666;
   margin:0;
   padding-left: 1em;
   border-left: 0.5em #EEE solid;
}

hr {
   height: 0px;
   border-bottom: none;
   border-top-width: thin;
   border-top-style: dotted;
   border-top-color: #999999;
}

@media print {
   * {
      background: transparent !important;
      color: black !important;
      filter:none !important;
      -ms-filter: none !important;
   }

   body {
      font-size:12pt;
      max-width:100%;
   }

   a, a:visited {
      text-decoration: underline;
   }

   hr {
      visibility: hidden;
      page-break-before: always;
   }

   pre, blockquote {
      padding-right: 1em;
      page-break-inside: avoid;
   }

   tr, img {
      page-break-inside: avoid;
   }

   img {
      max-width: 100% !important;
   }

   @page :left {
      margin: 15mm 20mm 15mm 10mm;
   }

   @page :right {
      margin: 15mm 10mm 15mm 20mm;
   }

   p, h2, h3 {
      orphans: 3; widows: 3;
   }

   h2, h3 {
      page-break-after: avoid;
   }
}
</style>



</head>

<body>
<h1>Matrices and Arrays</h1>

<p>Let&#39;s review matrices</p>

<ul>
<li>Matrices are two-dimensional collections of values of the same type</li>
<li>We can have numeric, integer, character, or logical matrices, character matrices.</li>
<li>You can&#39;t mix types within a matrix</li>
</ul>

<pre><code class="r">mat &lt;- matrix(rnorm(12), nrow = 3, ncol = 4)
mat
</code></pre>

<pre><code>##             [,1]         [,2]       [,3]       [,4]
## [1,]  0.16948170  1.096887672 -0.3555411 -0.8743144
## [2,] -0.07039246 -0.006625566  1.3512491  1.4038786
## [3,] -0.18620038 -1.210567314 -0.1553964  0.5576612
</code></pre>

<pre><code class="r"># vectorized calcs work with matrices too
mat*4
</code></pre>

<pre><code>##            [,1]        [,2]       [,3]      [,4]
## [1,]  0.6779268  4.38755069 -1.4221642 -3.497258
## [2,] -0.2815698 -0.02650226  5.4049965  5.615514
## [3,] -0.7448015 -4.84226926 -0.6215855  2.230645
</code></pre>

<pre><code class="r">mat &lt;- cbind(mat, 1:3)
mat
</code></pre>

<pre><code>##             [,1]         [,2]       [,3]       [,4] [,5]
## [1,]  0.16948170  1.096887672 -0.3555411 -0.8743144    1
## [2,] -0.07039246 -0.006625566  1.3512491  1.4038786    2
## [3,] -0.18620038 -1.210567314 -0.1553964  0.5576612    3
</code></pre>

<p>Arrays are like matrices but can have more or fewer than two dimensions.</p>

<pre><code class="r">arr &lt;- array(rnorm(12), c(2, 3, 4))
arr
</code></pre>

<pre><code>## , , 1
## 
##           [,1]       [,2]       [,3]
## [1,]  1.577152 -0.9767243 -0.7769179
## [2,] -2.084372 -0.2225279  1.7817800
## 
## , , 2
## 
##             [,1]      [,2]       [,3]
## [1,] -0.03765717 -1.295946 -1.6248505
## [2,]  0.54551682  1.283226  0.2194269
## 
## , , 3
## 
##           [,1]       [,2]       [,3]
## [1,]  1.577152 -0.9767243 -0.7769179
## [2,] -2.084372 -0.2225279  1.7817800
## 
## , , 4
## 
##             [,1]      [,2]       [,3]
## [1,] -0.03765717 -1.295946 -1.6248505
## [2,]  0.54551682  1.283226  0.2194269
</code></pre>

<h1>Attributes</h1>

<p>Objects have <em>attributes</em>.</p>

<pre><code class="r">attributes(mat)
</code></pre>

<pre><code>## $dim
## [1] 3 5
</code></pre>

<pre><code class="r">rownames(mat) &lt;- c(&#39;first&#39;, &#39;middle&#39;, &#39;last&#39;)
mat
</code></pre>

<pre><code>##               [,1]         [,2]       [,3]       [,4] [,5]
## first   0.16948170  1.096887672 -0.3555411 -0.8743144    1
## middle -0.07039246 -0.006625566  1.3512491  1.4038786    2
## last   -0.18620038 -1.210567314 -0.1553964  0.5576612    3
</code></pre>

<pre><code class="r">attributes(mat)
</code></pre>

<pre><code>## $dim
## [1] 3 5
## 
## $dimnames
## $dimnames[[1]]
## [1] &quot;first&quot;  &quot;middle&quot; &quot;last&quot;  
## 
## $dimnames[[2]]
## NULL
</code></pre>

<pre><code class="r">names(attributes(air))
</code></pre>

<pre><code>## [1] &quot;names&quot;     &quot;class&quot;     &quot;row.names&quot;
</code></pre>

<pre><code class="r">attributes(air)$names
</code></pre>

<pre><code>##  [1] &quot;Year&quot;              &quot;Month&quot;             &quot;DayofMonth&quot;       
##  [4] &quot;DayOfWeek&quot;         &quot;DepTime&quot;           &quot;CRSDepTime&quot;       
##  [7] &quot;ArrTime&quot;           &quot;CRSArrTime&quot;        &quot;UniqueCarrier&quot;    
## [10] &quot;FlightNum&quot;         &quot;TailNum&quot;           &quot;ActualElapsedTime&quot;
## [13] &quot;CRSElapsedTime&quot;    &quot;AirTime&quot;           &quot;ArrDelay&quot;         
## [16] &quot;DepDelay&quot;          &quot;Origin&quot;            &quot;Dest&quot;             
## [19] &quot;Distance&quot;          &quot;TaxiIn&quot;            &quot;TaxiOut&quot;          
## [22] &quot;Cancelled&quot;         &quot;CancellationCode&quot;  &quot;Diverted&quot;         
## [25] &quot;CarrierDelay&quot;      &quot;WeatherDelay&quot;      &quot;NASDelay&quot;         
## [28] &quot;SecurityDelay&quot;     &quot;LateAircraftDelay&quot;
</code></pre>

<pre><code class="r">attributes(air)$row.names[1:10]
</code></pre>

<pre><code>##  [1]  1  2  3  4  5  6  7  8  9 10
</code></pre>

<p>Now let&#39;s do a bit of manipulation and see if you can infer how R represents matrices internally.</p>

<pre><code class="r">mat[4]
</code></pre>

<pre><code>## [1] 1.096888
</code></pre>

<pre><code class="r">attributes(mat) &lt;- NULL
mat
</code></pre>

<pre><code>##  [1]  0.169481700 -0.070392458 -0.186200383  1.096887672 -0.006625566
##  [6] -1.210567314 -0.355541060  1.351249120 -0.155396379 -0.874314388
## [11]  1.403878607  0.557661202  1.000000000  2.000000000  3.000000000
</code></pre>

<pre><code class="r">is.matrix(mat)
</code></pre>

<pre><code>## [1] FALSE
</code></pre>

<p><strong>Question</strong>: What can you infer about what a matrix is in R?</p>

<p><strong>Question</strong>: What kind of object are the attributes themselves? How do I check?</p>

<h1>Matrices are stored column-major</h1>

<p>This is like Fortran, MATLAB and Julia but not like C or Python(numpy). </p>

<pre><code class="r">mat &lt;- matrix(1:12, 3, 4)
mat
</code></pre>

<pre><code>##      [,1] [,2] [,3] [,4]
## [1,]    1    4    7   10
## [2,]    2    5    8   11
## [3,]    3    6    9   12
</code></pre>

<pre><code class="r">c(mat)
</code></pre>

<pre><code>##  [1]  1  2  3  4  5  6  7  8  9 10 11 12
</code></pre>

<p>You can go smoothly back and forth between a matrix (or an array) and a vector:</p>

<pre><code class="r">identical(mat, matrix(c(mat), 3, 4))
</code></pre>

<pre><code>## [1] TRUE
</code></pre>

<pre><code class="r">identical(mat, matrix(c(mat), 3, 4, byrow = TRUE))
</code></pre>

<pre><code>## [1] FALSE
</code></pre>

<p>This is a common cause of bugs!</p>

<h1>Missing values and other special values</h1>

<p>Since it was designed by statisticians, R handles missing values very well relative to other languages.</p>

<ul>
<li><code>NA</code> is a missing value</li>
</ul>

<pre><code class="r">vec &lt;- rnorm(12)
vec[c(3, 5)] &lt;- NA
vec
</code></pre>

<pre><code>##  [1]  0.02297773  0.75935385          NA  0.40790175          NA
##  [6]  0.30357006  0.27942261 -0.40157252  1.46973582 -0.37691225
## [11] -0.13375929  0.26860626
</code></pre>

<pre><code class="r">length(vec)
</code></pre>

<pre><code>## [1] 12
</code></pre>

<pre><code class="r">sum(vec)
</code></pre>

<pre><code>## [1] NA
</code></pre>

<pre><code class="r">sum(vec, na.rm = TRUE)
</code></pre>

<pre><code>## [1] 2.599324
</code></pre>

<pre><code class="r">hist(vec)
</code></pre>

<p><img src="data:image/png;base64,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" alt=""/></p>

<pre><code class="r">is.na(vec)
</code></pre>

<pre><code>##  [1] FALSE FALSE  TRUE FALSE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE
## [12] FALSE
</code></pre>

<p>Be careful because many R functions won&#39;t warn you that they are ignoring the missing values.</p>

<ul>
<li>To infinity and beyond</li>
</ul>

<pre><code class="r">big &lt;- 1e500 
big
</code></pre>

<pre><code>## [1] Inf
</code></pre>

<pre><code class="r">big + 7
</code></pre>

<pre><code>## [1] Inf
</code></pre>

<ul>
<li><code>NaN</code> stands for Not a Number</li>
</ul>

<pre><code class="r">sqrt(-5)
</code></pre>

<pre><code>## Warning in sqrt(-5): NaNs produced
</code></pre>

<pre><code>## [1] NaN
</code></pre>

<pre><code class="r">big - big
</code></pre>

<pre><code>## [1] NaN
</code></pre>

<pre><code class="r">1/0
</code></pre>

<pre><code>## [1] Inf
</code></pre>

<ul>
<li><code>NULL</code></li>
</ul>

<pre><code class="r">vec &lt;- c(vec, NULL) 
vec
</code></pre>

<pre><code>##  [1]  0.02297773  0.75935385          NA  0.40790175          NA
##  [6]  0.30357006  0.27942261 -0.40157252  1.46973582 -0.37691225
## [11] -0.13375929  0.26860626
</code></pre>

<pre><code class="r">length(vec)
</code></pre>

<pre><code>## [1] 12
</code></pre>

<pre><code class="r">a &lt;- NULL
a + 7
</code></pre>

<pre><code>## numeric(0)
</code></pre>

<pre><code class="r">a[3, 4]
</code></pre>

<pre><code>## NULL
</code></pre>

<pre><code class="r">is.null(a)
</code></pre>

<pre><code>## [1] TRUE
</code></pre>

<pre><code class="r">myList &lt;- list(a = 7, b = 5)
myList$a &lt;- NULL  # works for data frames too
myList
</code></pre>

<pre><code>## $b
## [1] 5
</code></pre>

<p><code>NA</code> can hold a place but <code>NULL</code> cannot.
<code>NULL</code> is useful for having a function argument default to &#39;nothing&#39;. See <code>help(crossprod)</code>, which can compute either \(X^{\top}X\) or \(X^{\top}Y\).  </p>

<h1>Logical vectors</h1>

<pre><code class="r">answers &lt;- c(TRUE, TRUE, FALSE, FALSE)
update &lt;- c(TRUE, FALSE, TRUE, FALSE)

answers &amp; update
</code></pre>

<pre><code>## [1]  TRUE FALSE FALSE FALSE
</code></pre>

<pre><code class="r">answers | update
</code></pre>

<pre><code>## [1]  TRUE  TRUE  TRUE FALSE
</code></pre>

<pre><code class="r"># note the vectorized boolean arithmetic

# what am I doing here?
sum(answers)
</code></pre>

<pre><code>## [1] 2
</code></pre>

<pre><code class="r">mean(answers)
</code></pre>

<pre><code>## [1] 0.5
</code></pre>

<pre><code class="r">answers + update
</code></pre>

<pre><code>## [1] 2 1 1 0
</code></pre>

<p><strong>Question</strong>: What do you think R is doing to do arithmetic on logical vectors?</p>

<p>Tricks with logicals&hellip;</p>

<pre><code class="r">identical(answers &amp; update, as.logical(answers * update))
</code></pre>

<pre><code>## [1] TRUE
</code></pre>

<pre><code class="r">identical(answers | update, as.logical(answers + update))
</code></pre>

<pre><code>## [1] TRUE
</code></pre>

<h1>Data frames</h1>

<p>A review from Module 1&hellip;</p>

<ul>
<li>Data frames are combinations of vectors of the same length, but can be of different types</li>
<li>Data frames are what is used for standard rectangular (record by field) datasets, similar to a spreadsheet</li>
<li>Data frames are a functionality that both sets R aside from some languages (e.g., Matlab) and provides functionality similar to some statistical packages (e.g., Stata, SAS)</li>
</ul>

<pre><code class="r">air &lt;- read.csv(&#39;../data/airline.csv&#39;)
class(air)
</code></pre>

<pre><code>## [1] &quot;data.frame&quot;
</code></pre>

<pre><code class="r">head(air)
</code></pre>

<pre><code>##   Year Month DayofMonth DayOfWeek DepTime CRSDepTime ArrTime CRSArrTime
## 1 2005     1          1         6    1211       1216    1451       1502
## 2 2005     1          2         7    1209       1216    1447       1502
## 3 2005     1          3         1    1213       1216    1454       1502
##   UniqueCarrier FlightNum TailNum ActualElapsedTime CRSElapsedTime AirTime
## 1            UA       548  N341UA               100            106      81
## 2            UA       548  N398UA                98            106      79
## 3            UA       548  N303UA               101            106      83
##   ArrDelay DepDelay Origin Dest Distance TaxiIn TaxiOut Cancelled
## 1      -11       -5    SFO  SLC      599      2      17         0
## 2      -15       -7    SFO  SLC      599      2      17         0
## 3       -8       -3    SFO  SLC      599      3      15         0
##   CancellationCode Diverted CarrierDelay WeatherDelay NASDelay
## 1                         0            0            0        0
## 2                         0            0            0        0
## 3                         0            0            0        0
##   SecurityDelay LateAircraftDelay
## 1             0                 0
## 2             0                 0
## 3             0                 0
##  [ reached getOption(&quot;max.print&quot;) -- omitted 3 rows ]
</code></pre>

<pre><code class="r">str(air)
</code></pre>

<pre><code>## &#39;data.frame&#39;:    539895 obs. of  29 variables:
##  $ Year             : int  2005 2005 2005 2005 2005 2005 2005 2005 2005 2005 ...
##  $ Month            : int  1 1 1 1 1 1 1 1 1 1 ...
##  $ DayofMonth       : int  1 2 3 4 5 6 7 8 9 10 ...
##  $ DayOfWeek        : int  6 7 1 2 3 4 5 6 7 1 ...
##  $ DepTime          : int  1211 1209 1213 NA 1211 1214 1330 1213 1206 1338 ...
##  $ CRSDepTime       : int  1216 1216 1216 1216 1216 1215 1215 1215 1215 1215 ...
##  $ ArrTime          : int  1451 1447 1454 NA 1504 1506 1620 1448 1443 1610 ...
##  $ CRSArrTime       : int  1502 1502 1502 1502 1502 1505 1505 1505 1505 1505 ...
##  $ UniqueCarrier    : chr  &quot;UA&quot; &quot;UA&quot; &quot;UA&quot; &quot;UA&quot; ...
##  $ FlightNum        : int  548 548 548 548 548 548 548 548 548 548 ...
##  $ TailNum          : chr  &quot;N341UA&quot; &quot;N398UA&quot; &quot;N303UA&quot; &quot;000000&quot; ...
##  $ ActualElapsedTime: int  100 98 101 NA 113 112 110 95 97 92 ...
##  $ CRSElapsedTime   : int  106 106 106 106 106 110 110 110 110 110 ...
##  $ AirTime          : int  81 79 83 NA 85 95 85 72 77 78 ...
##  $ ArrDelay         : int  -11 -15 -8 NA 2 1 75 -17 -22 65 ...
##  $ DepDelay         : int  -5 -7 -3 NA -5 -1 75 -2 -9 83 ...
##  $ Origin           : chr  &quot;SFO&quot; &quot;SFO&quot; &quot;SFO&quot; &quot;SFO&quot; ...
##  $ Dest             : chr  &quot;SLC&quot; &quot;SLC&quot; &quot;SLC&quot; &quot;SLC&quot; ...
##  $ Distance         : int  599 599 599 599 599 599 599 599 599 599 ...
##  $ TaxiIn           : int  2 2 3 0 6 6 6 3 3 3 ...
##  $ TaxiOut          : int  17 17 15 0 22 11 19 20 17 11 ...
##  $ Cancelled        : int  0 0 0 1 0 0 0 0 0 0 ...
##  $ CancellationCode : chr  &quot;&quot; &quot;&quot; &quot;&quot; &quot;A&quot; ...
##  $ Diverted         : int  0 0 0 0 0 0 0 0 0 0 ...
##  $ CarrierDelay     : int  0 0 0 0 0 0 0 0 0 0 ...
##  $ WeatherDelay     : int  0 0 0 0 0 0 0 0 0 0 ...
##  $ NASDelay         : int  0 0 0 0 0 0 3 0 0 0 ...
##  $ SecurityDelay    : int  0 0 0 0 0 0 0 0 0 0 ...
##  $ LateAircraftDelay: int  0 0 0 0 0 0 72 0 0 65 ...
</code></pre>

<h1>Data frames are (special) lists!</h1>

<pre><code class="r">is.list(air)
</code></pre>

<pre><code>## [1] TRUE
</code></pre>

<pre><code class="r">length(air)
</code></pre>

<pre><code>## [1] 29
</code></pre>

<pre><code class="r">air[[3]][1:5]
</code></pre>

<pre><code>## [1] 1 2 3 4 5
</code></pre>

<pre><code class="r">lapply(air, class) 
</code></pre>

<pre><code>## $Year
## [1] &quot;integer&quot;
## 
## $Month
## [1] &quot;integer&quot;
## 
## $DayofMonth
## [1] &quot;integer&quot;
## 
## $DayOfWeek
## [1] &quot;integer&quot;
## 
## $DepTime
## [1] &quot;integer&quot;
## 
## $CRSDepTime
## [1] &quot;integer&quot;
## 
## $ArrTime
## [1] &quot;integer&quot;
## 
## $CRSArrTime
## [1] &quot;integer&quot;
## 
## $UniqueCarrier
## [1] &quot;character&quot;
## 
## $FlightNum
## [1] &quot;integer&quot;
## 
## $TailNum
## [1] &quot;character&quot;
## 
## $ActualElapsedTime
## [1] &quot;integer&quot;
## 
## $CRSElapsedTime
## [1] &quot;integer&quot;
## 
## $AirTime
## [1] &quot;integer&quot;
## 
## $ArrDelay
## [1] &quot;integer&quot;
## 
## $DepDelay
## [1] &quot;integer&quot;
## 
## $Origin
## [1] &quot;character&quot;
## 
## $Dest
## [1] &quot;character&quot;
## 
## $Distance
## [1] &quot;integer&quot;
## 
## $TaxiIn
## [1] &quot;integer&quot;
## 
## $TaxiOut
## [1] &quot;integer&quot;
## 
## $Cancelled
## [1] &quot;integer&quot;
## 
## $CancellationCode
## [1] &quot;character&quot;
## 
## $Diverted
## [1] &quot;integer&quot;
## 
## $CarrierDelay
## [1] &quot;integer&quot;
## 
## $WeatherDelay
## [1] &quot;integer&quot;
## 
## $NASDelay
## [1] &quot;integer&quot;
## 
## $SecurityDelay
## [1] &quot;integer&quot;
## 
## $LateAircraftDelay
## [1] &quot;integer&quot;
</code></pre>

<p><code>lapply()</code> is a function used on lists; it works here to apply the <code>class()</code> function to each element of the list, which in this case is each field/column.</p>

<h1>But lists are also vectors!</h1>

<pre><code class="r">length(air)
</code></pre>

<pre><code>## [1] 29
</code></pre>

<pre><code class="r">someFields &lt;- air[c(3,5)]
head(someFields)
</code></pre>

<pre><code>##   DayofMonth DepTime
## 1          1    1211
## 2          2    1209
## 3          3    1213
## 4          4      NA
## 5          5    1211
## 6          6    1214
</code></pre>

<pre><code class="r">identical(air[c(3,5)], air[ , c(3,5)])
</code></pre>

<pre><code>## [1] TRUE
</code></pre>

<p>In general the placement of commas in R is crucial, but here, two different operations give the same result because of the underlying structure of data frames.</p>

<h1>Factors</h1>

<ul>
<li>A factor is a special data type in R used for categorical data. In some cases it works like magic and in others it is incredibly frustrating. </li>
</ul>

<pre><code class="r">class(air$Dest)
</code></pre>

<pre><code>## [1] &quot;character&quot;
</code></pre>

<pre><code class="r">head(air$Dest) # What order are the factors in?
</code></pre>

<pre><code>## [1] &quot;SLC&quot; &quot;SLC&quot; &quot;SLC&quot; &quot;SLC&quot; &quot;SLC&quot; &quot;SLC&quot;
</code></pre>

<pre><code class="r">levels(air[[&quot;Dest&quot;]])  # note alternate way to get the variable
</code></pre>

<pre><code>## NULL
</code></pre>

<pre><code class="r">summary(air$Dest)
</code></pre>

<pre><code>##    Length     Class      Mode 
##    539895 character character
</code></pre>

<ul>
<li>What if we don&#39;t like the order these are in? Factor order is important for all kinds of things like plotting, analysis of variance, regression output, and more</li>
</ul>

<h1>Ordering the Factor</h1>

<ul>
<li>Ordered factors simply have an additional attribute explaining the order of the levels of a factor</li>
<li>This is a useful shortcut when we want to preserve some of the meaning provided by the order</li>
<li>Think ordinal data</li>
</ul>

<pre><code class="r"># first let&#39;s do some pre-processing to get set up for the example
air$DepDelayCens &lt;- air$DepDelay
air$DepDelayCens[air$DepDelayCens &gt; 60] &lt;- 60
air$DepDelayCens[air$DepDelayCens &lt; 0] &lt;- 0
air$DayOfWeek &lt;- as.factor(air$DayOfWeek)
air$DayOfWeekSun &lt;- ordered(air$DayOfWeek, 
     levels = levels(air$DayOfWeek)[c(7,1,2,3,4,5,6)])

# alternative coding
# air &lt;- within(air, 
#     DayOfWeekSun &lt;- ordered(DayOfWeek, 
#        levels = levels(DayOfWeek)[c(7,1,2,3,4,5,6)])
#)

head(air$DayOfWeekSun)
</code></pre>

<pre><code>## [1] 6 7 1 2 3 4
## Levels: 7 &lt; 1 &lt; 2 &lt; 3 &lt; 4 &lt; 5 &lt; 6
</code></pre>

<pre><code class="r">levels(air$DayOfWeekSun)
</code></pre>

<pre><code>## [1] &quot;7&quot; &quot;1&quot; &quot;2&quot; &quot;3&quot; &quot;4&quot; &quot;5&quot; &quot;6&quot;
</code></pre>

<pre><code class="r">levels(air$DayOfWeekSun) &lt;- c(&quot;Sun&quot;,&quot;Mon&quot;,&quot;Tue&quot;,&quot;Wed&quot;,&quot;Thu&quot;,&quot;Fri&quot;,&quot;Sat&quot;)
boxplot(DepDelayCens ~ DayOfWeekSun, data = air)
</code></pre>

<p><img src="data:image/png;base64,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" alt=""/></p>

<p><strong>Challenge</strong>: Try to decipher what I just did with that complicated single line of code starting with <code>within</code>.</p>

<h1>Reclassifying Factors</h1>

<ul>
<li>Turning factors into other data types can be tricky. All factors have an underlying numeric structure.</li>
</ul>

<pre><code class="r">students &lt;- factor(c(&#39;basic&#39;,&#39;proficient&#39;,&#39;advanced&#39;,&#39;basic&#39;, 
      &#39;advanced&#39;, &#39;minimal&#39;))
levels(students)
</code></pre>

<pre><code>## [1] &quot;advanced&quot;   &quot;basic&quot;      &quot;minimal&quot;    &quot;proficient&quot;
</code></pre>

<pre><code class="r">unclass(students)
</code></pre>

<pre><code>## [1] 2 4 1 2 1 3
## attr(,&quot;levels&quot;)
## [1] &quot;advanced&quot;   &quot;basic&quot;      &quot;minimal&quot;    &quot;proficient&quot;
</code></pre>

<ul>
<li>Hmmm, what happened?</li>
<li>Be careful! The best way to convert a factor is to convert it to a character first.</li>
</ul>

<pre><code class="r">students &lt;- factor(c(&#39;basic&#39;,&#39;proficient&#39;,&#39;advanced&#39;,&#39;basic&#39;, 
      &#39;advanced&#39;, &#39;minimal&#39;))
score = c(minimal = 3, basic = 1, advanced = 13, proficient = 7) # a named vector
score[&quot;advanced&quot;]  # look up by name
</code></pre>

<pre><code>## advanced 
##       13
</code></pre>

<pre><code class="r">students[3]
</code></pre>

<pre><code>## [1] advanced
## Levels: advanced basic minimal proficient
</code></pre>

<pre><code class="r">score[students[3]]
</code></pre>

<pre><code>## minimal 
##       3
</code></pre>

<pre><code class="r">score[as.character(students[3])]
</code></pre>

<pre><code>## advanced 
##       13
</code></pre>

<p>What went wrong and how did we fix it?  Notice how easily this could be a big bug in your code.</p>

<h1>Subsetting</h1>

<p>There are many ways to select subsets in R. The syntax below is useful for vectors, matrices, data frames, arrays and lists.</p>

<pre><code class="r">vec &lt;- rnorm(20)
mat &lt;- matrix(vec, 4, 5)
rownames(mat) &lt;- letters[1:4]
mat
</code></pre>

<pre><code>##          [,1]       [,2]       [,3]       [,4]       [,5]
## a -0.07890798  0.4801053 0.49898859  1.0078743 -2.5804635
## b -1.32317568  0.2437549 0.02466561  0.9344412 -0.9218429
## c -0.93144644 -1.3914161 0.34499383 -0.7270437 -0.1744985
## d  0.40737888  0.2417938 1.64812423 -0.5357524  0.4401284
</code></pre>

<p>1) by direct indexing</p>

<pre><code class="r">vec[c(3, 5, 12:14)]
</code></pre>

<pre><code>## [1] -0.9314464  0.4801053  1.6481242  1.0078743  0.9344412
</code></pre>

<pre><code class="r">vec[-c(3,5)]
</code></pre>

<pre><code>##  [1] -0.07890798 -1.32317568  0.40737888  0.24375486 -1.39141612
##  [6]  0.24179383  0.49898859  0.02466561  0.34499383  1.64812423
## [11]  1.00787431  0.93444119 -0.72704368 -0.53575243 -2.58046354
## [16] -0.92184295 -0.17449848  0.44012841
</code></pre>

<pre><code class="r">mat[c(2,4), 5]
</code></pre>

<pre><code>##          b          d 
## -0.9218429  0.4401284
</code></pre>

<pre><code class="r">rowInd &lt;- c(1, 3, 4)
colInd &lt;- c(2, 2, 1)
elemInd &lt;- cbind(rowInd, colInd)
elemInd
</code></pre>

<pre><code>##      rowInd colInd
## [1,]      1      2
## [2,]      3      2
## [3,]      4      1
</code></pre>

<pre><code class="r">mat[elemInd]
</code></pre>

<pre><code>## [1]  0.4801053 -1.3914161  0.4073789
</code></pre>

<p>Note the last usage where we give it a 2-column matrix of indices</p>

<p>2) by a vector of logicals</p>

<pre><code class="r">cond &lt;- vec &gt; 0
vec[cond]
</code></pre>

<pre><code>##  [1] 0.40737888 0.48010534 0.24375486 0.24179383 0.49898859 0.02466561
##  [7] 0.34499383 1.64812423 1.00787431 0.93444119 0.44012841
</code></pre>

<pre><code class="r">air[air$DepDelay &gt; 60*12 &amp; !is.na(air$DepDelay), ]
</code></pre>

<pre><code>##        Year Month DayofMonth DayOfWeek DepTime CRSDepTime ArrTime
## 71351  2005     7         23         6     633       1545    1212
## 80042  2005     8         20         6    2237       1030     122
## 115794 2005    11          2         3    1009        630    1526
##        CRSArrTime UniqueCarrier FlightNum TailNum ActualElapsedTime
## 71351        2113            NW       354  N586NW               219
## 80042        1301            TZ      4603  N561TZ               345
## 115794       1207            NW       368  N552NW               197
##        CRSElapsedTime AirTime ArrDelay DepDelay Origin Dest Distance
## 71351             208     184      899      888    SFO  MSP     1589
## 80042             331     323      741      727    SFO  LIH     2447
## 115794            217     175     1639     1659    SFO  MSP     1589
##        TaxiIn TaxiOut Cancelled CancellationCode Diverted CarrierDelay
## 71351      13      22         0                         0          888
## 80042       5      17         0                         0          652
## 115794      3      19         0                         0         1639
##        WeatherDelay NASDelay SecurityDelay LateAircraftDelay DepDelayCens
## 71351             0       11             0                 0           60
## 80042             0       14             0                75           60
## 115794            0        0             0                 0           60
##        DayOfWeekSun
## 71351           Sat
## 80042           Sat
## 115794          Wed
##  [ reached getOption(&quot;max.print&quot;) -- omitted 11 rows ]
</code></pre>

<p>What happened in the last subsetting operation?</p>

<p>3) by a vector of names</p>

<pre><code class="r">mat[c(&#39;a&#39;, &#39;d&#39;, &#39;a&#39;), ]
</code></pre>

<pre><code>##          [,1]      [,2]      [,3]       [,4]       [,5]
## a -0.07890798 0.4801053 0.4989886  1.0078743 -2.5804635
## d  0.40737888 0.2417938 1.6481242 -0.5357524  0.4401284
## a -0.07890798 0.4801053 0.4989886  1.0078743 -2.5804635
</code></pre>

<p>4) using <em>subset()</em></p>

<pre><code class="r">subset(air, DepDelay &gt; 60*12)
</code></pre>

<pre><code>##        Year Month DayofMonth DayOfWeek DepTime CRSDepTime ArrTime
## 71351  2005     7         23         6     633       1545    1212
## 80042  2005     8         20         6    2237       1030     122
## 115794 2005    11          2         3    1009        630    1526
##        CRSArrTime UniqueCarrier FlightNum TailNum ActualElapsedTime
## 71351        2113            NW       354  N586NW               219
## 80042        1301            TZ      4603  N561TZ               345
## 115794       1207            NW       368  N552NW               197
##        CRSElapsedTime AirTime ArrDelay DepDelay Origin Dest Distance
## 71351             208     184      899      888    SFO  MSP     1589
## 80042             331     323      741      727    SFO  LIH     2447
## 115794            217     175     1639     1659    SFO  MSP     1589
##        TaxiIn TaxiOut Cancelled CancellationCode Diverted CarrierDelay
## 71351      13      22         0                         0          888
## 80042       5      17         0                         0          652
## 115794      3      19         0                         0         1639
##        WeatherDelay NASDelay SecurityDelay LateAircraftDelay DepDelayCens
## 71351             0       11             0                 0           60
## 80042             0       14             0                75           60
## 115794            0        0             0                 0           60
##        DayOfWeekSun
## 71351           Sat
## 80042           Sat
## 115794          Wed
##  [ reached getOption(&quot;max.print&quot;) -- omitted 11 rows ]
</code></pre>

<p>5) using <em>dplyr</em> tools such as <em>filter()</em> and <em>select()</em> &ndash; more in Module 5</p>

<h1>Assignment into subsets</h1>

<p>We can assign into subsets by using similar syntax, as we saw with vectors.</p>

<pre><code class="r">vec[c(3, 5, 12:14)] &lt;- 1:5
mat[2, 3:5] &lt;- rnorm(3)
mat[mat[,1] &gt; 0, ] &lt;- -Inf
</code></pre>

<h1>Strings</h1>

<p>R has lots of functionality for character strings. Usually these are stored as vectors of strings, each with arbitrary length.</p>

<pre><code class="r">chars &lt;- c(&#39;hi&#39;, &#39;hallo&#39;, &quot;mother&#39;s&quot;, &#39;father\&#39;s&#39;, &quot;He said, \&quot;hi\&quot;&quot; )
length(chars)
</code></pre>

<pre><code>## [1] 5
</code></pre>

<pre><code class="r">nchar(chars)
</code></pre>

<pre><code>## [1]  2  5  8  8 13
</code></pre>

<pre><code class="r">paste(&quot;bill&quot;, &quot;clinton&quot;, sep = &quot; &quot;)  # paste together a set of strings
</code></pre>

<pre><code>## [1] &quot;bill clinton&quot;
</code></pre>

<pre><code class="r">paste(chars, collapse = &#39; &#39;)  # paste together things from a vector
</code></pre>

<pre><code>## [1] &quot;hi hallo mother&#39;s father&#39;s He said, \&quot;hi\&quot;&quot;
</code></pre>

<pre><code class="r">strsplit(&quot;This is the R bootcamp&quot;, split = &quot; &quot;)
</code></pre>

<pre><code>## [[1]]
## [1] &quot;This&quot;     &quot;is&quot;       &quot;the&quot;      &quot;R&quot;        &quot;bootcamp&quot;
</code></pre>

<pre><code class="r">substring(chars, 2, 3)
</code></pre>

<pre><code>## [1] &quot;i&quot;  &quot;al&quot; &quot;ot&quot; &quot;at&quot; &quot;e &quot;
</code></pre>

<pre><code class="r">chars2 &lt;- chars
substring(chars2, 2, 3) &lt;- &quot;ZZ&quot;
chars2
</code></pre>

<pre><code>## [1] &quot;hZ&quot;              &quot;hZZlo&quot;           &quot;mZZher&#39;s&quot;        &quot;fZZher&#39;s&quot;       
## [5] &quot;HZZsaid, \&quot;hi\&quot;&quot;
</code></pre>

<p>We can search for patterns in character vectors and replace patterns (both vectorized!)</p>

<pre><code class="r">grep(&quot;ther&quot;, chars)
</code></pre>

<pre><code>## [1] 3 4
</code></pre>

<pre><code class="r">gsub(&quot;hi&quot;, &quot;Hi&quot;, chars)
</code></pre>

<pre><code>## [1] &quot;Hi&quot;              &quot;hallo&quot;           &quot;mother&#39;s&quot;        &quot;father&#39;s&quot;       
## [5] &quot;He said, \&quot;Hi\&quot;&quot;
</code></pre>

<h1>Regular expressions (regex or regexp)</h1>

<p>Some of you may be familiar with using <em>regular expressions</em>, which is functionality for doing sophisticated pattern matching and replacement with strings. <em>Python</em> and <em>Perl</em> are both used extensively for such text manipulation. </p>

<p>R has a full set of regular expression capabilities available through the <em>grep()</em>, <em>gregexpr()</em>, and <em>gsub()</em> functions (among others - many R functions will work with regular expressions). A particularly nice way to make use of this functionality is to use the <em>stringr</em> package, which is more user-friendly than directly using the core R functions.</p>

<p>You can basically do any regular expression/string manipulations in R, though the syntax may be a bit clunky at times.</p>

<h1>More details on reading data into R</h1>

<p>Remember that you&#39;ll need to know the current working directory so that you know where R is looking for files.</p>

<p>The workhorse for reading into a data frame is <em>read.table()</em>, which allows any separator (CSV, tab-delimited, etc.). <em>read.csv()</em> is a special case of <em>read.table()</em> for CSV files.</p>

<p>You&#39;ve already seen a bit of this, but let&#39;s work through a more involved example, so you can see some of the steps and tricks involved in reading data into R.</p>

<pre><code class="r">rta &lt;- read.table(&quot;../data/RTAData.csv&quot;, sep = &quot;,&quot;, head = TRUE)
rta[1:5, 1:5]
</code></pre>

<pre><code>##               time X40010 X40015 X40020 X40025
## 1 2010-03-01 14:58    821    209    828    258
## 2 2010-03-01 15:01    804    209    804    248
## 3 2010-03-01 15:04    892    212    801    237
## 4 2010-03-01 15:07    857    214    821    243
## 5 2010-03-01 15:10    849    222    834    252
</code></pre>

<pre><code class="r">dim(rta)
</code></pre>

<pre><code>## [1] 120822     62
</code></pre>

<pre><code class="r"># great, we&#39;re all set, right?
# Not so fast...
unlist(lapply(rta, class))[1:5]
</code></pre>

<pre><code>##        time      X40010      X40015      X40020      X40025 
## &quot;character&quot; &quot;character&quot; &quot;character&quot; &quot;character&quot; &quot;character&quot;
</code></pre>

<pre><code class="r"># ?read.table
rta2 &lt;- read.table(&quot;../data/RTAData.csv&quot;, sep = &quot;,&quot;, 
  head = TRUE, stringsAsFactors = FALSE)
rta2[3,3]
</code></pre>

<pre><code>## [1] &quot;212&quot;
</code></pre>

<pre><code class="r">unlist(lapply(rta2, class))[1:5]
</code></pre>

<pre><code>##        time      X40010      X40015      X40020      X40025 
## &quot;character&quot; &quot;character&quot; &quot;character&quot; &quot;character&quot; &quot;character&quot;
</code></pre>

<pre><code class="r"># let&#39;s delve more deeply
levels(rta[ , 2])[c(1:5, 3041:3044)]
</code></pre>

<pre><code>## NULL
</code></pre>

<pre><code class="r">rta3 &lt;- read.table(&quot;../data/RTAData.csv&quot;, sep = &quot;,&quot;, head = TRUE, 
      stringsAsFactors = FALSE, na.strings = c(&#39;NA&#39;, &#39;x&#39;))
unlist(lapply(rta3, class))[1:5]
</code></pre>

<pre><code>##        time      X40010      X40015      X40020      X40025 
## &quot;character&quot;   &quot;integer&quot;   &quot;integer&quot;   &quot;integer&quot;   &quot;integer&quot;
</code></pre>

<pre><code class="r"># checking...
missing &lt;- which(rta[ , 2] == &quot;&quot;)
missing[1:5]
</code></pre>

<pre><code>## [1] 1167 1168 1169 1170 1171
</code></pre>

<pre><code class="r">rta3[head(missing), ]
</code></pre>

<pre><code>##                  time X40010 X40015 X40020 X40025 X40030 X40035 X40040
## 1167 2010-03-04 01:16     NA     NA     NA     NA     NA     NA     NA
##      X40045 X40050 X40055 X40060 X40065 X40070 X40075 X40080 X40085 X40090
## 1167     NA     NA     NA     NA     NA     NA     NA     NA     NA     NA
##      X40092 X40095 X40100 X40105 X40110 X40115 X40120 X40125 X40130 X40135
## 1167     NA     NA     NA     NA     NA     NA     NA     NA     NA     NA
##      X40140 X40145 X40150 X41010 X41015 X41020 X41025 X41030 X41035 X41040
## 1167     NA     NA     NA     NA     NA     NA     NA     NA     NA     NA
##      X41045 X41050 X41055 X41060 X41065 X41070 X41075 X41080 X41085 X41090
## 1167     NA     NA     NA     NA     NA     NA     NA     NA     NA     NA
##      X41095 X41100 X41105 X41110 X41115 X41120 X41125 X41130 X41135 X41140
## 1167     NA     NA     NA     NA     NA     NA     NA     NA     NA     NA
##      X41145 X41150 X41155 X41160
## 1167     NA     NA     NA     NA
##  [ reached getOption(&quot;max.print&quot;) -- omitted 5 rows ]
</code></pre>

<p>It&#39;s good to first look at your data in plain text format outside of R and then to check it after you&#39;ve read it into R.</p>

<h1>Other ways to read data into R</h1>

<p>The <em>read.table()</em> family of functions just skims the surface of things&hellip;</p>

<p>1) You can also read in a file as vector of characters, one character string per line of the file with <em>readLines()</em>, and then post-process it. 
2) You can read fixed width format (constant number of characters per field) with <em>read.fwf()</em>.
3) <em>read_csv()</em> (and <em>read_lines()</em>, <em>read_fwf()</em>, etc.) in the <em>readr</em> package is a faster, more helpful drop-in replacement for <em>read.csv()</em> that plays well with <em>dplyr</em> (see Module 5).
4) the <em>data.table</em> package is great for reading and manipulating large datasets (orders of gigabytes or 10s of gigabytes).</p>

<h1>Breakout</h1>

<h3>Basics</h3>

<p>1) Extract the 5th row from the airline dataset.</p>

<p>2) Extract the last row from the airline dataset.</p>

<p>3) Count the number of NAs in the departure delay field of the airline dataset.</p>

<p>4) Set all of the extreme delays (more than 300 minutes) to NA.</p>

<p>5) Consider the first row of the airline dataset, which has UA flight number 548. How do I create a string &ldquo;UA-548&rdquo; using <code>air$UniqueCarrier[1]</code> and <code>air$FlightNum[1]</code>? </p>

<h3>Using the ideas</h3>

<p>6) Create a character string using <code>paste()</code> that tells the user how many rows there are in the data frame - do this programmatically such that it would work for any data frame regardless of how many rows it has. The result should look like this: &ldquo;There are 56,234,234 rows in the dataset&rdquo;</p>

<p>7) If you didn&#39;t do it this way already, extract the last row from the airline dataset without typing the number &#39;539895&#39;.</p>

<p>8) Create a boolean vector indicating if flight on the carrier WN (Southwest) and distance is less than 1000 miles and calculate the proportion of all the flights these represent.</p>

<p>9) Use that vector to create a new data frame that is a subset of the original data frame.</p>

<p>10) Consider the attributes of the <em>air</em> dataset. What kind of R object is the set of attributes?</p>

<h3>Advanced</h3>

<p>11) Make the destination variable a factor variable and reorder the levels by the number of arrivals from SFO at the destinations. Now create a boxplot of departure delay by destination for January, 2005.</p>

<p>12) Create row names for the data frame based on concatenating the Year, Month, DayofMonth, UniqueCarrier and FlightNum fields.</p>

</body>

</html>
