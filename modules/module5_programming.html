<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>

<title>Loops</title>

<script type="text/javascript">
window.onload = function() {
  var imgs = document.getElementsByTagName('img'), i, img;
  for (i = 0; i < imgs.length; i++) {
    img = imgs[i];
    // center an image if it is the only element of its parent
    if (img.parentElement.childElementCount === 1)
      img.parentElement.style.textAlign = 'center';
  }
};
</script>

<!-- Styles for R syntax highlighter -->
<style type="text/css">
   pre .operator,
   pre .paren {
     color: rgb(104, 118, 135)
   }

   pre .literal {
     color: #990073
   }

   pre .number {
     color: #099;
   }

   pre .comment {
     color: #998;
     font-style: italic
   }

   pre .keyword {
     color: #900;
     font-weight: bold
   }

   pre .identifier {
     color: rgb(0, 0, 0);
   }

   pre .string {
     color: #d14;
   }
</style>

<!-- R syntax highlighter -->
<script type="text/javascript">
var hljs=new function(){function m(p){return p.replace(/&/gm,"&amp;").replace(/</gm,"&lt;")}function f(r,q,p){return RegExp(q,"m"+(r.cI?"i":"")+(p?"g":""))}function b(r){for(var p=0;p<r.childNodes.length;p++){var q=r.childNodes[p];if(q.nodeName=="CODE"){return q}if(!(q.nodeType==3&&q.nodeValue.match(/\s+/))){break}}}function h(t,s){var p="";for(var r=0;r<t.childNodes.length;r++){if(t.childNodes[r].nodeType==3){var q=t.childNodes[r].nodeValue;if(s){q=q.replace(/\n/g,"")}p+=q}else{if(t.childNodes[r].nodeName=="BR"){p+="\n"}else{p+=h(t.childNodes[r])}}}if(/MSIE [678]/.test(navigator.userAgent)){p=p.replace(/\r/g,"\n")}return p}function a(s){var r=s.className.split(/\s+/);r=r.concat(s.parentNode.className.split(/\s+/));for(var q=0;q<r.length;q++){var p=r[q].replace(/^language-/,"");if(e[p]){return p}}}function c(q){var p=[];(function(s,t){for(var r=0;r<s.childNodes.length;r++){if(s.childNodes[r].nodeType==3){t+=s.childNodes[r].nodeValue.length}else{if(s.childNodes[r].nodeName=="BR"){t+=1}else{if(s.childNodes[r].nodeType==1){p.push({event:"start",offset:t,node:s.childNodes[r]});t=arguments.callee(s.childNodes[r],t);p.push({event:"stop",offset:t,node:s.childNodes[r]})}}}}return t})(q,0);return p}function k(y,w,x){var q=0;var z="";var s=[];function u(){if(y.length&&w.length){if(y[0].offset!=w[0].offset){return(y[0].offset<w[0].offset)?y:w}else{return w[0].event=="start"?y:w}}else{return y.length?y:w}}function t(D){var A="<"+D.nodeName.toLowerCase();for(var B=0;B<D.attributes.length;B++){var C=D.attributes[B];A+=" "+C.nodeName.toLowerCase();if(C.value!==undefined&&C.value!==false&&C.value!==null){A+='="'+m(C.value)+'"'}}return A+">"}while(y.length||w.length){var v=u().splice(0,1)[0];z+=m(x.substr(q,v.offset-q));q=v.offset;if(v.event=="start"){z+=t(v.node);s.push(v.node)}else{if(v.event=="stop"){var p,r=s.length;do{r--;p=s[r];z+=("</"+p.nodeName.toLowerCase()+">")}while(p!=v.node);s.splice(r,1);while(r<s.length){z+=t(s[r]);r++}}}}return z+m(x.substr(q))}function j(){function q(x,y,v){if(x.compiled){return}var u;var s=[];if(x.k){x.lR=f(y,x.l||hljs.IR,true);for(var w in x.k){if(!x.k.hasOwnProperty(w)){continue}if(x.k[w] instanceof Object){u=x.k[w]}else{u=x.k;w="keyword"}for(var r in u){if(!u.hasOwnProperty(r)){continue}x.k[r]=[w,u[r]];s.push(r)}}}if(!v){if(x.bWK){x.b="\\b("+s.join("|")+")\\s"}x.bR=f(y,x.b?x.b:"\\B|\\b");if(!x.e&&!x.eW){x.e="\\B|\\b"}if(x.e){x.eR=f(y,x.e)}}if(x.i){x.iR=f(y,x.i)}if(x.r===undefined){x.r=1}if(!x.c){x.c=[]}x.compiled=true;for(var t=0;t<x.c.length;t++){if(x.c[t]=="self"){x.c[t]=x}q(x.c[t],y,false)}if(x.starts){q(x.starts,y,false)}}for(var p in e){if(!e.hasOwnProperty(p)){continue}q(e[p].dM,e[p],true)}}function d(B,C){if(!j.called){j();j.called=true}function q(r,M){for(var L=0;L<M.c.length;L++){if((M.c[L].bR.exec(r)||[null])[0]==r){return M.c[L]}}}function v(L,r){if(D[L].e&&D[L].eR.test(r)){return 1}if(D[L].eW){var M=v(L-1,r);return M?M+1:0}return 0}function w(r,L){return L.i&&L.iR.test(r)}function K(N,O){var M=[];for(var L=0;L<N.c.length;L++){M.push(N.c[L].b)}var r=D.length-1;do{if(D[r].e){M.push(D[r].e)}r--}while(D[r+1].eW);if(N.i){M.push(N.i)}return f(O,M.join("|"),true)}function p(M,L){var N=D[D.length-1];if(!N.t){N.t=K(N,E)}N.t.lastIndex=L;var r=N.t.exec(M);return r?[M.substr(L,r.index-L),r[0],false]:[M.substr(L),"",true]}function z(N,r){var L=E.cI?r[0].toLowerCase():r[0];var M=N.k[L];if(M&&M instanceof Array){return M}return false}function F(L,P){L=m(L);if(!P.k){return L}var r="";var O=0;P.lR.lastIndex=0;var M=P.lR.exec(L);while(M){r+=L.substr(O,M.index-O);var N=z(P,M);if(N){x+=N[1];r+='<span class="'+N[0]+'">'+M[0]+"</span>"}else{r+=M[0]}O=P.lR.lastIndex;M=P.lR.exec(L)}return r+L.substr(O,L.length-O)}function J(L,M){if(M.sL&&e[M.sL]){var r=d(M.sL,L);x+=r.keyword_count;return r.value}else{return F(L,M)}}function I(M,r){var L=M.cN?'<span class="'+M.cN+'">':"";if(M.rB){y+=L;M.buffer=""}else{if(M.eB){y+=m(r)+L;M.buffer=""}else{y+=L;M.buffer=r}}D.push(M);A+=M.r}function G(N,M,Q){var R=D[D.length-1];if(Q){y+=J(R.buffer+N,R);return false}var P=q(M,R);if(P){y+=J(R.buffer+N,R);I(P,M);return P.rB}var L=v(D.length-1,M);if(L){var O=R.cN?"</span>":"";if(R.rE){y+=J(R.buffer+N,R)+O}else{if(R.eE){y+=J(R.buffer+N,R)+O+m(M)}else{y+=J(R.buffer+N+M,R)+O}}while(L>1){O=D[D.length-2].cN?"</span>":"";y+=O;L--;D.length--}var r=D[D.length-1];D.length--;D[D.length-1].buffer="";if(r.starts){I(r.starts,"")}return R.rE}if(w(M,R)){throw"Illegal"}}var E=e[B];var D=[E.dM];var A=0;var x=0;var y="";try{var s,u=0;E.dM.buffer="";do{s=p(C,u);var t=G(s[0],s[1],s[2]);u+=s[0].length;if(!t){u+=s[1].length}}while(!s[2]);if(D.length>1){throw"Illegal"}return{r:A,keyword_count:x,value:y}}catch(H){if(H=="Illegal"){return{r:0,keyword_count:0,value:m(C)}}else{throw H}}}function g(t){var p={keyword_count:0,r:0,value:m(t)};var r=p;for(var q in e){if(!e.hasOwnProperty(q)){continue}var s=d(q,t);s.language=q;if(s.keyword_count+s.r>r.keyword_count+r.r){r=s}if(s.keyword_count+s.r>p.keyword_count+p.r){r=p;p=s}}if(r.language){p.second_best=r}return p}function i(r,q,p){if(q){r=r.replace(/^((<[^>]+>|\t)+)/gm,function(t,w,v,u){return w.replace(/\t/g,q)})}if(p){r=r.replace(/\n/g,"<br>")}return r}function n(t,w,r){var x=h(t,r);var v=a(t);var y,s;if(v){y=d(v,x)}else{return}var q=c(t);if(q.length){s=document.createElement("pre");s.innerHTML=y.value;y.value=k(q,c(s),x)}y.value=i(y.value,w,r);var u=t.className;if(!u.match("(\\s|^)(language-)?"+v+"(\\s|$)")){u=u?(u+" "+v):v}if(/MSIE [678]/.test(navigator.userAgent)&&t.tagName=="CODE"&&t.parentNode.tagName=="PRE"){s=t.parentNode;var p=document.createElement("div");p.innerHTML="<pre><code>"+y.value+"</code></pre>";t=p.firstChild.firstChild;p.firstChild.cN=s.cN;s.parentNode.replaceChild(p.firstChild,s)}else{t.innerHTML=y.value}t.className=u;t.result={language:v,kw:y.keyword_count,re:y.r};if(y.second_best){t.second_best={language:y.second_best.language,kw:y.second_best.keyword_count,re:y.second_best.r}}}function o(){if(o.called){return}o.called=true;var r=document.getElementsByTagName("pre");for(var p=0;p<r.length;p++){var q=b(r[p]);if(q){n(q,hljs.tabReplace)}}}function l(){if(window.addEventListener){window.addEventListener("DOMContentLoaded",o,false);window.addEventListener("load",o,false)}else{if(window.attachEvent){window.attachEvent("onload",o)}else{window.onload=o}}}var e={};this.LANGUAGES=e;this.highlight=d;this.highlightAuto=g;this.fixMarkup=i;this.highlightBlock=n;this.initHighlighting=o;this.initHighlightingOnLoad=l;this.IR="[a-zA-Z][a-zA-Z0-9_]*";this.UIR="[a-zA-Z_][a-zA-Z0-9_]*";this.NR="\\b\\d+(\\.\\d+)?";this.CNR="\\b(0[xX][a-fA-F0-9]+|(\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?)";this.BNR="\\b(0b[01]+)";this.RSR="!|!=|!==|%|%=|&|&&|&=|\\*|\\*=|\\+|\\+=|,|\\.|-|-=|/|/=|:|;|<|<<|<<=|<=|=|==|===|>|>=|>>|>>=|>>>|>>>=|\\?|\\[|\\{|\\(|\\^|\\^=|\\||\\|=|\\|\\||~";this.ER="(?![\\s\\S])";this.BE={b:"\\\\.",r:0};this.ASM={cN:"string",b:"'",e:"'",i:"\\n",c:[this.BE],r:0};this.QSM={cN:"string",b:'"',e:'"',i:"\\n",c:[this.BE],r:0};this.CLCM={cN:"comment",b:"//",e:"$"};this.CBLCLM={cN:"comment",b:"/\\*",e:"\\*/"};this.HCM={cN:"comment",b:"#",e:"$"};this.NM={cN:"number",b:this.NR,r:0};this.CNM={cN:"number",b:this.CNR,r:0};this.BNM={cN:"number",b:this.BNR,r:0};this.inherit=function(r,s){var p={};for(var q in r){p[q]=r[q]}if(s){for(var q in s){p[q]=s[q]}}return p}}();hljs.LANGUAGES.cpp=function(){var a={keyword:{"false":1,"int":1,"float":1,"while":1,"private":1,"char":1,"catch":1,"export":1,virtual:1,operator:2,sizeof:2,dynamic_cast:2,typedef:2,const_cast:2,"const":1,struct:1,"for":1,static_cast:2,union:1,namespace:1,unsigned:1,"long":1,"throw":1,"volatile":2,"static":1,"protected":1,bool:1,template:1,mutable:1,"if":1,"public":1,friend:2,"do":1,"return":1,"goto":1,auto:1,"void":2,"enum":1,"else":1,"break":1,"new":1,extern:1,using:1,"true":1,"class":1,asm:1,"case":1,typeid:1,"short":1,reinterpret_cast:2,"default":1,"double":1,register:1,explicit:1,signed:1,typename:1,"try":1,"this":1,"switch":1,"continue":1,wchar_t:1,inline:1,"delete":1,alignof:1,char16_t:1,char32_t:1,constexpr:1,decltype:1,noexcept:1,nullptr:1,static_assert:1,thread_local:1,restrict:1,_Bool:1,complex:1},built_in:{std:1,string:1,cin:1,cout:1,cerr:1,clog:1,stringstream:1,istringstream:1,ostringstream:1,auto_ptr:1,deque:1,list:1,queue:1,stack:1,vector:1,map:1,set:1,bitset:1,multiset:1,multimap:1,unordered_set:1,unordered_map:1,unordered_multiset:1,unordered_multimap:1,array:1,shared_ptr:1}};return{dM:{k:a,i:"</",c:[hljs.CLCM,hljs.CBLCLM,hljs.QSM,{cN:"string",b:"'\\\\?.",e:"'",i:"."},{cN:"number",b:"\\b(\\d+(\\.\\d*)?|\\.\\d+)(u|U|l|L|ul|UL|f|F)"},hljs.CNM,{cN:"preprocessor",b:"#",e:"$"},{cN:"stl_container",b:"\\b(deque|list|queue|stack|vector|map|set|bitset|multiset|multimap|unordered_map|unordered_set|unordered_multiset|unordered_multimap|array)\\s*<",e:">",k:a,r:10,c:["self"]}]}}}();hljs.LANGUAGES.r={dM:{c:[hljs.HCM,{cN:"number",b:"\\b0[xX][0-9a-fA-F]+[Li]?\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\b\\d+(?:[eE][+\\-]?\\d*)?L\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\b\\d+\\.(?!\\d)(?:i\\b)?",e:hljs.IMMEDIATE_RE,r:1},{cN:"number",b:"\\b\\d+(?:\\.\\d*)?(?:[eE][+\\-]?\\d*)?i?\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\.\\d+(?:[eE][+\\-]?\\d*)?i?\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"keyword",b:"(?:tryCatch|library|setGeneric|setGroupGeneric)\\b",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\.\\.\\.",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\.\\.\\d+(?![\\w.])",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\b(?:function)",e:hljs.IMMEDIATE_RE,r:2},{cN:"keyword",b:"(?:if|in|break|next|repeat|else|for|return|switch|while|try|stop|warning|require|attach|detach|source|setMethod|setClass)\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"literal",b:"(?:NA|NA_integer_|NA_real_|NA_character_|NA_complex_)\\b",e:hljs.IMMEDIATE_RE,r:10},{cN:"literal",b:"(?:NULL|TRUE|FALSE|T|F|Inf|NaN)\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"identifier",b:"[a-zA-Z.][a-zA-Z0-9._]*\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"operator",b:"<\\-(?!\\s*\\d)",e:hljs.IMMEDIATE_RE,r:2},{cN:"operator",b:"\\->|<\\-",e:hljs.IMMEDIATE_RE,r:1},{cN:"operator",b:"%%|~",e:hljs.IMMEDIATE_RE},{cN:"operator",b:">=|<=|==|!=|\\|\\||&&|=|\\+|\\-|\\*|/|\\^|>|<|!|&|\\||\\$|:",e:hljs.IMMEDIATE_RE,r:0},{cN:"operator",b:"%",e:"%",i:"\\n",r:1},{cN:"identifier",b:"`",e:"`",r:0},{cN:"string",b:'"',e:'"',c:[hljs.BE],r:0},{cN:"string",b:"'",e:"'",c:[hljs.BE],r:0},{cN:"paren",b:"[[({\\])}]",e:hljs.IMMEDIATE_RE,r:0}]}};
hljs.initHighlightingOnLoad();
</script>



<style type="text/css">
body, td {
   font-family: sans-serif;
   background-color: white;
   font-size: 13px;
}

body {
  max-width: 800px;
  margin: auto;
  padding: 1em;
  line-height: 20px;
}

tt, code, pre {
   font-family: 'DejaVu Sans Mono', 'Droid Sans Mono', 'Lucida Console', Consolas, Monaco, monospace;
}

h1 {
   font-size:2.2em;
}

h2 {
   font-size:1.8em;
}

h3 {
   font-size:1.4em;
}

h4 {
   font-size:1.0em;
}

h5 {
   font-size:0.9em;
}

h6 {
   font-size:0.8em;
}

a:visited {
   color: rgb(50%, 0%, 50%);
}

pre, img {
  max-width: 100%;
}
pre {
  overflow-x: auto;
}
pre code {
   display: block; padding: 0.5em;
}

code {
  font-size: 92%;
  border: 1px solid #ccc;
}

code[class] {
  background-color: #F8F8F8;
}

table, td, th {
  border: none;
}

blockquote {
   color:#666666;
   margin:0;
   padding-left: 1em;
   border-left: 0.5em #EEE solid;
}

hr {
   height: 0px;
   border-bottom: none;
   border-top-width: thin;
   border-top-style: dotted;
   border-top-color: #999999;
}

@media print {
   * {
      background: transparent !important;
      color: black !important;
      filter:none !important;
      -ms-filter: none !important;
   }

   body {
      font-size:12pt;
      max-width:100%;
   }

   a, a:visited {
      text-decoration: underline;
   }

   hr {
      visibility: hidden;
      page-break-before: always;
   }

   pre, blockquote {
      padding-right: 1em;
      page-break-inside: avoid;
   }

   tr, img {
      page-break-inside: avoid;
   }

   img {
      max-width: 100% !important;
   }

   @page :left {
      margin: 15mm 20mm 15mm 10mm;
   }

   @page :right {
      margin: 15mm 10mm 15mm 20mm;
   }

   p, h2, h3 {
      orphans: 3; widows: 3;
   }

   h2, h3 {
      page-break-after: avoid;
   }
}
</style>



</head>

<body>
<h1>Loops</h1>

<p>In many languages, looping (for loops, while loops, etc.) is one of the main
constructs used to carry out computation. Loops are not emphasized as much in R,
both because they can be slow and because other syntax is often cleaner.</p>

<p>But there are lots of times when using a loop does make sense.</p>

<p>Most of you are probably familiar at least with the basic idea of iterating
through a series of steps. A for loop iterates through a pre-determined number
of iterations, while a while loop iterates until some condition is met. For
loops are more common in R, but while loops can be handy particularly for things
like optimization.</p>

<p>Let&#39;s take our use of <code>aggregate()</code> from Module 4 and use a for loop instead.</p>

<pre><code class="r">DestSubset &lt;- c(&#39;LAX&#39;,&#39;SEA&#39;,&#39;PHX&#39;,&#39;DEN&#39;,&#39;MSP&#39;,&#39;OAK&#39;,&#39;JFK&#39;,&#39;ATL&#39;,&#39;DFW&#39;,&#39;IAH&#39;,
                &#39;ORD&#39;)
airSmall &lt;- subset(air, Dest %in% DestSubset)
airSmall$late &lt;- airSmall$DepDelay &gt;= 15
airSmall$Month &lt;- as.factor(airSmall$Month)
airSmall$Month &lt;- relevel(airSmall$Month, &quot;5&quot;)
airSmall$Dest &lt;- as.character(airSmall$Dest)

out &lt;- list()
length(out) &lt;- length(DestSubset)
names(out) &lt;- DestSubset

for (i in seq_along(DestSubset)) {
     # equivalently: for(i in 1:length(DestSubset))
     # n.b., seq_along(x) is better than 1:length(x), since it handles the case
     # where the length of an object is 0 or NULL more robustly.
     sub &lt;- subset(airSmall, airSmall$Dest == DestSubset[i])
     if (sum(!is.na(sub$late)) &amp;&amp; length(sub$late) &gt; 1) {
     # fit logistic regression
       out[[i]] &lt;- glm(late ~ Month, family = binomial, data = sub)
     } else {
       out[[i]] &lt;- NA
     }
}
out[[&#39;OAK&#39;]]
</code></pre>

<pre><code>## [1] NA
</code></pre>

<pre><code class="r">summary(out[[&#39;IAH&#39;]])
</code></pre>

<pre><code>## 
## Call:
## glm(formula = late ~ Month, family = binomial, data = sub)
## 
## Deviance Residuals: 
##     Min       1Q   Median       3Q      Max  
## -0.7365  -0.6121  -0.5750  -0.5252   2.2963  
## 
## Coefficients:
##              Estimate Std. Error z value Pr(&gt;|z|)    
## (Intercept) -1.816777   0.096439 -18.839  &lt; 2e-16 ***
## Month1       0.100730   0.136079   0.740   0.4592    
## Month2       0.204195   0.136910   1.491   0.1358    
## Month3       0.329094   0.129520   2.541   0.0111 *  
## Month4       0.153730   0.133867   1.148   0.2508    
## Month6       0.568904   0.124816   4.558 5.17e-06 ***
## Month7       0.237044   0.129051   1.837   0.0662 .  
## Month8       0.136570   0.131184   1.041   0.2978    
## Month9      -0.745516   0.166948  -4.466 7.99e-06 ***
## Month10      0.002425   0.136671   0.018   0.9858    
## Month11     -0.094463   0.140825  -0.671   0.5024    
## Month12      0.650724   0.124100   5.244 1.58e-07 ***
## ---
## Signif. codes:  0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1
## 
## (Dispersion parameter for binomial family taken to be 1)
## 
##     Null deviance: 9334.1  on 10533  degrees of freedom
## Residual deviance: 9199.0  on 10522  degrees of freedom
##   (48 observations deleted due to missingness)
## AIC: 9223
## 
## Number of Fisher Scoring iterations: 5
</code></pre>

<pre><code class="r">summary(out[[&#39;ORD&#39;]])
</code></pre>

<pre><code>## 
## Call:
## glm(formula = late ~ Month, family = binomial, data = sub)
## 
## Deviance Residuals: 
##     Min       1Q   Median       3Q      Max  
## -0.8681  -0.7585  -0.7065  -0.6374   1.8404  
## 
## Coefficients:
##             Estimate Std. Error z value Pr(&gt;|z|)    
## (Intercept) -1.36737    0.05601 -24.414  &lt; 2e-16 ***
## Month1       0.34839    0.07732   4.506 6.61e-06 ***
## Month2       0.33658    0.07946   4.236 2.28e-05 ***
## Month3       0.26875    0.07777   3.456 0.000549 ***
## Month4       0.10664    0.07912   1.348 0.177701    
## Month6       0.48219    0.07538   6.397 1.59e-10 ***
## Month7       0.15244    0.07742   1.969 0.048939 *  
## Month8       0.12886    0.07773   1.658 0.097355 .  
## Month9      -0.11699    0.08168  -1.432 0.152086    
## Month10     -0.12304    0.08087  -1.521 0.128169    
## Month11      0.11599    0.07911   1.466 0.142599    
## Month12      0.58578    0.07505   7.805 5.95e-15 ***
## ---
## Signif. codes:  0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1
## 
## (Dispersion parameter for binomial family taken to be 1)
## 
##     Null deviance: 24639  on 22500  degrees of freedom
## Residual deviance: 24453  on 22489  degrees of freedom
##   (483 observations deleted due to missingness)
## AIC: 24477
## 
## Number of Fisher Scoring iterations: 4
</code></pre>

<p>The iterations do not have to explicitly be over sequential numbers.</p>

<pre><code class="r">for (dest in DestSubset) {
     cat(dest, &#39;\n&#39;)
}
</code></pre>

<pre><code>## LAX 
## SEA 
## PHX 
## DEN 
## MSP 
## OAK 
## JFK 
## ATL 
## DFW 
## IAH 
## ORD
</code></pre>

<h1>While loop</h1>

<p>It&#39;s not a particularly interesting example, but we can see the <code>while</code> loop
syntax in the same example.</p>

<pre><code class="r">out &lt;- list(); length(out) &lt;- length(DestSubset); names(out) &lt;- DestSubset

i &lt;- 1
while (i &lt;= length(DestSubset)) {
     sub &lt;- subset(airSmall, airSmall$Dest == DestSubset[i])
     if (sum(!is.na(sub$late)) &amp;&amp; length(sub$late) &gt; 1) {
     # fit logistic regression
       out[[i]] &lt;- glm(late ~ Month, family = binomial, data = sub)
     } else {
       out[[i]] &lt;- NA
     }
     i = i + 1
}
summary(out[[&#39;IAH&#39;]])
</code></pre>

<pre><code>## 
## Call:
## glm(formula = late ~ Month, family = binomial, data = sub)
## 
## Deviance Residuals: 
##     Min       1Q   Median       3Q      Max  
## -0.7365  -0.6121  -0.5750  -0.5252   2.2963  
## 
## Coefficients:
##              Estimate Std. Error z value Pr(&gt;|z|)    
## (Intercept) -1.816777   0.096439 -18.839  &lt; 2e-16 ***
## Month1       0.100730   0.136079   0.740   0.4592    
## Month2       0.204195   0.136910   1.491   0.1358    
## Month3       0.329094   0.129520   2.541   0.0111 *  
## Month4       0.153730   0.133867   1.148   0.2508    
## Month6       0.568904   0.124816   4.558 5.17e-06 ***
## Month7       0.237044   0.129051   1.837   0.0662 .  
## Month8       0.136570   0.131184   1.041   0.2978    
## Month9      -0.745516   0.166948  -4.466 7.99e-06 ***
## Month10      0.002425   0.136671   0.018   0.9858    
## Month11     -0.094463   0.140825  -0.671   0.5024    
## Month12      0.650724   0.124100   5.244 1.58e-07 ***
## ---
## Signif. codes:  0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1
## 
## (Dispersion parameter for binomial family taken to be 1)
## 
##     Null deviance: 9334.1  on 10533  degrees of freedom
## Residual deviance: 9199.0  on 10522  degrees of freedom
##   (48 observations deleted due to missingness)
## AIC: 9223
## 
## Number of Fisher Scoring iterations: 5
</code></pre>

<h1>Branching (if-then-else syntax)</h1>

<p>We already saw an example of branching in the <em>for</em> loop example.</p>

<p>Here&#39;s a simple example to illustrate the syntax. Note that the <em>then</em> is
implicit.</p>

<pre><code class="r">val &lt;- rnorm(1)
val
</code></pre>

<pre><code>## [1] 0.4490384
</code></pre>

<pre><code class="r">if (val &lt; 0) {
  print(&quot;val is negative&quot;)
} else {
  print(&quot;val is positive&quot;)
}
</code></pre>

<pre><code>## [1] &quot;val is positive&quot;
</code></pre>

<p>We can chain together <code>if</code> statements as follows.</p>

<pre><code class="r">val &lt;- rnorm(1)
val
</code></pre>

<pre><code>## [1] -0.5668044
</code></pre>

<pre><code class="r">if (val &lt; -1) {
  print(&quot;val is more than one standard deviation below the mean.&quot;)
} else if (abs(val) &lt;= 1) {
  print(&quot;val is within one standard deviation of the mean.&quot;)
} else {
  print(&quot;val is more than one standard deviation above the mean.&quot;)
}
</code></pre>

<pre><code>## [1] &quot;val is within one standard deviation of the mean.&quot;
</code></pre>

<p>In general, the <code>{</code> brackets are only needed if you have multiple R expressions,
but R will complain when an <code>else</code> starts a line of code, so generally using the
<code>{</code> is good practice. That said, this <em>works just fine</em>:</p>

<pre><code class="r">if (val &lt; 0) print(&quot;val is negative&quot;) else print(&quot;val is positive&quot;)
</code></pre>

<pre><code>## [1] &quot;val is negative&quot;
</code></pre>

<h1>The condition in an if statement</h1>

<p>The condition in the if statement cannot be NA or R will give an error. This is
a very common bug.</p>

<p>Suppose we were (inefficiently) setting up a new field using an if statement.</p>

<pre><code class="r">air$late &lt;- rep(0, nrow(air))
for (i in 1:20) {
      if(air$DepDelay[i] &gt; 15)
          air$late[i] &lt;- 1 else air$late[i] &lt;- 0
}
</code></pre>

<pre><code>## Error in if (air$DepDelay[i] &gt; 15) air$late[i] &lt;- 1 else air$late[i] &lt;- 0: missing value where TRUE/FALSE needed
</code></pre>

<pre><code class="r">print(i)
</code></pre>

<pre><code>## [1] 4
</code></pre>

<pre><code class="r">if(air$DepDelay[4] &gt; 15) print(&#39;here&#39;)
</code></pre>

<pre><code>## Error in if (air$DepDelay[4] &gt; 15) print(&quot;here&quot;): missing value where TRUE/FALSE needed
</code></pre>

<pre><code class="r">air$DepDelay[4] &gt; 15
</code></pre>

<pre><code>## [1] NA
</code></pre>

<pre><code class="r">air$DepDelay[4]
</code></pre>

<pre><code>## [1] NA
</code></pre>

<p>An <code>NA</code>/<code>NaN</code> is the main reason an if statement may fail, because R will
generally convert other values to logical values.</p>

<p>Zero evaluates to <code>FALSE</code>, all other numbers evaluate to <code>TRUE</code>. In general
strings are not converted to booleans.</p>

<h1>Flow control: <code>next</code> and <code>break</code> statements</h1>

<p><code>next</code> skips the current evaluation of the loop statements:</p>

<pre><code class="r">out &lt;- list(); length(out) &lt;- length(DestSubset); names(out) &lt;- DestSubset

for (i in seq_along(DestSubset)) {
     # equivalently: for(i in 1:length(DestSubset))
     sub &lt;- subset(airSmall, airSmall$Dest == DestSubset[i])
     if(sum(!is.na(sub$late)) &amp;&amp; length(sub$late) &gt; 1) {
     # fit logistic regression
       out[[i]] &lt;- glm(late ~ Month, family = binomial, data = sub)
     } else {
       next
     }
}
cat(&quot;We got to iteration &quot;, i, &quot; of &quot;, length(DestSubset), &quot; items.&quot;, sep = &quot;&quot;)
</code></pre>

<pre><code>## We got to iteration 11 of 11 items.
</code></pre>

<pre><code class="r">out[[&#39;OAK&#39;]]
</code></pre>

<pre><code>## NULL
</code></pre>

<p><code>break</code> immediately ends loop evaluation:</p>

<pre><code class="r">out &lt;- list(); length(out) &lt;- length(DestSubset); names(out) &lt;- DestSubset

for (i in seq_along(DestSubset)) {
     # equivalently: for(i in 1:length(DestSubset))
     sub &lt;- subset(airSmall, airSmall$Dest == DestSubset[i])
     if(sum(!is.na(sub$late)) &amp;&amp; length(sub$late) &gt; 1) {
     # fit logistic regression
       out[[i]] &lt;- glm(late ~ Month, family = binomial, data = sub)
     } else {
       break
     }
}
cat(&quot;We got to iteration &quot;, i, &quot; of &quot;, length(DestSubset), &quot; items.&quot;, sep = &quot;&quot;)
</code></pre>

<pre><code>## We got to iteration 6 of 11 items.
</code></pre>

<p>Effective use of <code>next</code> and <code>break</code> can make your <code>for</code> (and other) loops both
more robust and efficient (e.g., by skipping cases where computations may fail).</p>

<h1>Functions</h1>

<p>Functions are one of the most important constructs in R (and many other
languages). They allow you to modularize your code - encapsulating a set of
repeatable operations as an individual function call.</p>

<p>You should rely heavily on functions rather than having long sets of
expressions in R scripts.</p>

<p>Functions have many important advantages:</p>

<ul>
<li>They reduce bugs by avoiding having multiple instances of the same
functionality.</li>
<li>They reduce time involved in coding by eliminating redundancy.</li>
<li>They make for cleaner and more easily-readable code.</li>
</ul>

<p>A basic goal is writing functions is <em>modularity</em>.</p>

<p>In general, a function should</p>

<ul>
<li>be fairly short,</li>
<li>be focused and specific in what it does, and</li>
<li>be designed so that it can be used in combination with other functions to
carry out more complicated operations.</li>
</ul>

<h1>Writing functions</h1>

<p>In module 4, we sorted the airline <code>data.frame</code>.</p>

<pre><code class="r">ord &lt;- order(air$DepDelay, air$ArrDelay, decreasing = TRUE)
ord[1:5]
</code></pre>

<pre><code>## [1] 115794 396990 337213 168750 415550
</code></pre>

<pre><code class="r">air_ordered &lt;- air[ord, ]
</code></pre>

<p>How would we encapsulate that functionality generically so that
we can apply it to other <code>data.frame</code>s (or matrices)?</p>

<pre><code class="r">colSort &lt;- function(data, col1, col2) {
    # Sorts a matrix or dataframe based on two  columns
    #
    # Args:
    #     data: a dataframe or matrix with at least columns
    #                  and any number of rows
    #     col1: a reference to the column to sort on
    #     col2: a reference to the column to use for ties
    #
    # Returns:
    #     &lt;data&gt; sorted in increasing order by the values
    #     in the first column. Any ties should be broken by values
    #     in the second column. The row pairs should be maintained
    #     in this result

    ord &lt;- order(data[, col1], data[, col2], decreasing=TRUE)
    sorted &lt;- data[ord, ]
    return(sorted)
}

identical(air_ordered, colSort(air, &quot;DepDelay&quot;, &quot;ArrDelay&quot;))
</code></pre>

<pre><code>## [1] TRUE
</code></pre>

<p>Of course this is somewhat limited in that it is specific to sorting based on
two columns. We&#39;d usually want to extend this to be more general, but it&#39;s
usually good to start with something concrete and more limited in generality and
then generalize once you are sure it works.</p>

<h1>Function arguments</h1>

<p>R can match arguments by name (when provided) or by position (the fall-back). It
also allows one to specify default values so that the user doesn&#39;t have to
explicitly provide all the arguments.</p>

<pre><code class="r">colSort &lt;- function(data, col1 = 1, col2 = 2) {
    ord &lt;- order(data[, col1], data[, col2], decreasing=TRUE)
    sorted &lt;- data[ord, ]
    return(sorted)
}
identical(colSort(air, 1, 2), colSort(air))
</code></pre>

<pre><code>## [1] TRUE
</code></pre>

<pre><code class="r">identical(colSort(col2 = 2, data = air, col1 = 1), colSort(air, 1, 2))
</code></pre>

<pre><code>## [1] TRUE
</code></pre>

<h1>What is the &ldquo;&hellip;&rdquo; argument for?</h1>

<p>Using <code>...</code> as one of the arguments to a function allows a function to pass
along user-provided arguments without specifying explicitly what the user might
provide.</p>

<p>Here&#39;s an example of tailoring some plotting specifications that I use a lot. I
generally define <code>pplot()</code> in my <em>.Rprofile</em> file so it is always available to
me.</p>

<pre><code class="r">pplot &lt;- function(x, y, ...) {
      plot(x, y, pch = 16, cex = 0.6, ...)
}

sub &lt;- air[sample(1:nrow(air), 10000, replace = FALSE), ]
sub$DepDelay[sub$DepDelay &gt; 120] &lt;- 120
sub$DepDelay[sub$DepDelay &lt; -30] &lt;- -30
pplot(sub$Dist, sub$DepDelay, xlab = &#39;distance (miles)&#39;,
      ylab = &#39;delay (minutes)&#39;, log = &#39;x&#39;)
</code></pre>

<p><img src="data:image/png;base64,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" alt=""/></p>

<h1>Important concepts with R functions</h1>

<p>Functions in R return an object. In general, R functions are and should be
designed such that the only effect of the function is through the return value.</p>

<p><strong>Side effects</strong> are when a function affects the state of the world in
addition to its return value.  Can you think of any side effects that
you saw an R function produce from earlier today?  What about:</p>

<ul>
<li><code>library()</code></li>
<li><code>setwd()</code></li>
<li><code>plot()</code></li>
</ul>

<p>Functions in R are (roughly) <em>pass-by-value</em> and not <em>pass-by-reference</em>. This
means that if you modify an argument inside the function it will not change the
original value outside the function. This protects you from a major potential
source of side effects. (There are exceptions to this rule.)</p>

<p>In actuality, functions in R are <em>call-by-value</em>. What this means for our
purposes is that you can pass an input argument in without a copy being made of
it. This saves time and memory. At the time that you modify the input within the
function (if ever), then a copy is made and  the modified input is different
than the original value outside the function.</p>

<h1>Variable scope and global variables</h1>

<p>In general functions should not make use of variables from outside the function.
(However, for quick-and-dirty work and in some other circumstances, one may do
this.) This provides modularity and reduces bugs and surprises.</p>

<p>If R can&#39;t find a variable that is used in a function based on the function
arguments and variables defined locally in the function, it goes and looks
elsewhere following a set of rules called <em>lexical scoping</em>. (This type of
scoping has to do with R&#39;s roots (and explains why R is very similar to other
languages for functional programming) - we won&#39;t go into details here but
certainly worth looking into as you start using R more.)</p>

<p>Basically this means that it looks for variables relative to where the function
is defined (not relative to where the function is called).</p>

<p>This can get involved, but a couple brief examples illustrate the basic idea.</p>

<pre><code class="r">x &lt;- 2
f &lt;- function(y) {
    return(x + y)
}
f(1)
</code></pre>

<pre><code>## [1] 3
</code></pre>

<pre><code class="r">g &lt;- function(y) {
  x &lt;- 10
  return(f(y))
}

g(1)
</code></pre>

<pre><code>## [1] 3
</code></pre>

<pre><code class="r">g &lt;- function(y) {
  f &lt;- function(y) {
     return(x + y)
  }
  x &lt;- 10
  return(f(y))
}

g(1)
</code></pre>

<pre><code>## [1] 11
</code></pre>

<p>Note that <code>x</code> is used as a global variable here, which in general is bad
practice.</p>

<h1>When do I start programming?</h1>

<blockquote>
<p>“[W]e wanted users to be able to begin in an interactive environment,
where they did not consciously think of themselves as programming.
Then as their needs became clearer and their sophistication increased,
they should be able <strong>to slide gradually into programming, when the
language and system aspects would become more important</strong>.”</p>
</blockquote>

<p><a href="http://www.stat.bell-labs.com/S/history.html">John Chambers, “Stages in the Evolution of
S”</a></p>

<h1>Key Principles of R</h1>

<ul>
<li>Everything that exists is an object.</li>
<li><p>Everything that happens is a function call.</p>

<p><a href="http://user2014.stat.ucla.edu/files/chambers.pdf">John Chambers&#39; useR!2014
talk</a></p></li>
</ul>

<h3>What does the 2nd principle mean?</h3>

<p>Are arithmetic operations really just functions?</p>

<pre><code class="r">3+2
</code></pre>

<pre><code>## [1] 5
</code></pre>

<pre><code class="r">&#39;+&#39;(3,2)
</code></pre>

<pre><code>## [1] 5
</code></pre>

<p>Yes!</p>

<p>And what about indexing?</p>

<pre><code class="r">x &lt;- matrix(runif(100), 10)
x[ , 2]
</code></pre>

<pre><code>##  [1] 0.05774193 0.05854032 0.03139993 0.32938554 0.05288618 0.88365749
##  [7] 0.03469696 0.62662758 0.37583209 0.49306212
</code></pre>

<pre><code class="r">&#39;[&#39;(x , , 2)
</code></pre>

<pre><code>##  [1] 0.05774193 0.05854032 0.03139993 0.32938554 0.05288618 0.88365749
##  [7] 0.03469696 0.62662758 0.37583209 0.49306212
</code></pre>

<p>Also yes!</p>

<p>This holds more generally - one can investigate and see the same thing in terms
of a <code>for</code> loop.</p>

<h3>What does the 1st principle mean?</h3>

<pre><code class="r">class(1)
</code></pre>

<pre><code>## [1] &quot;numeric&quot;
</code></pre>

<pre><code class="r">class(runif)
</code></pre>

<pre><code>## [1] &quot;function&quot;
</code></pre>

<pre><code class="r">class(function(x) x^2)
</code></pre>

<pre><code>## [1] &quot;function&quot;
</code></pre>

<pre><code class="r">square &lt;- function(x) x^2
class(square)
</code></pre>

<pre><code>## [1] &quot;function&quot;
</code></pre>

<h1>Modern Functional Programming in R (Advanced)</h1>

<p>Now that we&#39;ve taken an extensive look at <code>for</code> loops and programming with
functions, we can move on from base R to look at more modern and powerful tools
for programming provided by <a href="http://purrr.tidyverse.org/"><code>purrr</code></a>, a core
package in the <a href="http://www.tidyverse.org/"><code>tidyverse</code></a>, a set of modern tools
for &ldquo;doing data science&rdquo; in R. <code>purrr</code> provides facilities to manipulate data
sets using functions in a &ldquo;tidy&rdquo; manner. Using <code>purrr</code> requires familiarity with
several other core packages of the <code>tidyverse</code>, most notably <code>dplyr</code> and
<code>magrittr</code>. We won&#39;t have time to cover details of how to use <code>purrr</code> here, but
we highly recommend you look into these packages as you continuing exploring R.</p>

<pre><code class="r">library(dplyr)
library(purrr)
</code></pre>

<p>We&#39;ll leave you with a simple example of how to use <code>purrr</code> to deal with a task
we already looked at with <code>for</code> loops. In fact, we&#39;ll return to the logistic
regression exercise that we started with.</p>

<h3>A simple example</h3>

<p>Let&#39;s take a look at our <code>airSmall</code> data set again. Recall that our goal was to
fit a logistic regression model, with the outcome being late arrival (binary)
and the only explanatory variable being the month. To fit our models across each
of the destination separately, we&#39;ll first need to put our data in &ldquo;tidy&rdquo;
format. It&#39;s <em>really easy</em> with some helpful verbs from <code>dplyr</code>&hellip;</p>

<pre><code class="r"># let&#39;s clean up the data set first
airSmall_tidy &lt;- airSmall %&gt;%
  split(.$Dest)
</code></pre>

<p>Now, we can fit our logistic regression models across each of the destinations
using <code>purrr</code>&#39;s <code>map</code>:</p>

<pre><code class="r">airSmall_glms &lt;- airSmall_tidy %&gt;%
  map(~glm(late ~ Month, family = binomial, data = .))
</code></pre>

<pre><code>## Error in `contrasts&lt;-`(`*tmp*`, value = contr.funs[1 + isOF[nn]]): contrasts can be applied only to factors with 2 or more levels
</code></pre>

<p>Uh oh, what happened here?</p>

<p>Oh, that&#39;s right&hellip;we had to protect against situations where there wasn&#39;t
enough variation in the outcome variable (all flights late or on time, or with
too much missing-ness). We did this with an <code>if</code> statement.</p>

<p>So, can <code>purrr</code> handle this? <em>Yes</em> - in fact, it&#39;s really easy. We can use a
verb called <code>safely</code> to separate situations where the GLM succeeds from those
where it doesn&#39;t. Let&#39;s try it out</p>

<pre><code class="r">airSmall_glms &lt;- airSmall_tidy %&gt;%
  map(safely(~glm(late ~ Month, family = binomial, data = .)))
</code></pre>

<p><em>Remark:</em> What we accomplish here with <code>purrr::map</code> is also easily done using
tools from base R. In fact, using <code>lapply</code>, we can evaluate the very same <code>glm</code>
formula with our <code>airSmall</code> dataset, albeit without the extra goodies offered by
the pipe (aka <code>%&gt;%</code>) syntax and the <code>safely</code> convenience, afforded by <code>magrittr</code>
and <code>purrr</code>, respectively.</p>

<p>Ok. Now, we&#39;ll look at the results for one destination, just to get a feel for
the output</p>

<pre><code class="r">airSmall_glms$LAX$result
</code></pre>

<pre><code>## 
## Call:  glm(formula = late ~ Month, family = binomial, data = .)
## 
## Coefficients:
## (Intercept)       Month1       Month2       Month3       Month4  
##    -1.53016      0.28260      0.26799      0.04350     -0.11293  
##      Month6       Month7       Month8       Month9      Month10  
##     0.36191      0.21491      0.08889     -0.09919      0.02030  
##     Month11      Month12  
##     0.05893      0.63107  
## 
## Degrees of Freedom: 43034 Total (i.e. Null);  43023 Residual
##   (1230 observations deleted due to missingness)
## Null Deviance:       43390 
## Residual Deviance: 43080     AIC: 43100
</code></pre>

<p>As a sanity check, we&#39;ll make sure our results match those from before. (We do
this for one destination city for convenience. When working, it never hurts to
be too safe - best to check them all.)</p>

<pre><code class="r">all.equal(coef(airSmall_glms$LAX$result), coef(out$LAX))
</code></pre>

<pre><code>## [1] TRUE
</code></pre>

<p>Looks like everything worked out just fine!</p>

<p>Now that we&#39;ve seen what we can do with <code>purrr</code>, it&#39;s important to compare this
modern approach to what is offered in base R. (It&#39;s very important to understand
and be comfortable with using tools from base R before adopting those that are
offered as part of the <code>tidyverse</code>.) To that end, here are some points of
comparison:</p>

<ul>
<li>Is <code>purrr::map</code> really different from <code>lapply</code>, <code>sapply</code>, <code>vapply</code>?

<ul>
<li><code>purrr</code> is:</li>
<li>Consistent in the type of object returned</li>
<li>contains many useful shortcuts and convenience functions (e.g., <code>safely</code>)</li>
<li>Syntax accommodates more complicated iteration schemes.</li>
<li>[l/s/v]<code>apply</code>:</li>
<li>The type of object returned is <em>not</em> always consistent</li>
<li>Has fewer dependencies (implented in base R rather than <code>tidyverse</code>)

<ul>
<li>Syntax can be unwieldy for more complex use-cases.</li>
</ul></li>
</ul></li>
</ul>

<p>For a full comparison of <code>purrr</code> versus base R, consider checking out <a href="https://jennybc.github.io/purrr-tutorial/bk01_base-functions.html">this
quite thorough
tutorial</a> by
Jenny Bryan.</p>

<h3>Onwards: Readings and References</h3>

<ul>
<li><p>A great reference for learning both basic and advanced concepts in using the R
language for data analysis is the book <em>R for Data Science</em>, by Garrett
Grolemund and Hadley Wickham. An online version is freely available and may be
accessed <a href="http://r4ds.had.co.nz/">here</a>. In particular, <a href="http://r4ds.had.co.nz/iteration.html">chapter 21
(&ldquo;Iteration&rdquo;)</a> is a great review of much
of what we have covered in this module.</p></li>
<li><p><a href="http://purrr.tidyverse.org/">Here</a> you can explore the documentation website
for the <code>purrr</code> package. It includes details about functionality we did not
have time to discuss and many useful examples that you can use to go further
with <code>purrr</code>.</p></li>
<li><p><a href="http://www.tidyverse.org/">Here</a> you can browse the <code>tidyverse</code> documentation
website. It includes an introduction to the core packages, the philosophy of
this ecosystem of packages, and much more.</p></li>
</ul>

<h1>Breakout</h1>

<h3>Basics</h3>

<p>1) Write an R function that will take an input vector and set any negative
values in the vector to zero.</p>

<h3>Using the ideas</h3>

<p>2) Write an R function that will take an input vector and set any value below a
threshold to be the value of threshold. Optionally, the function should instead
set values above a threshold to the value of the threshold.</p>

<p>3) Augment your function so that it checks that the input is a numeric vector
and return an error if not. (See the help information for <code>stop()</code>.)</p>

<p>4) Figure out what <code>invisible()</code> does and why it is useful when writing
functions. Use <code>invisible()</code> in your function from just above or in the
<code>colSort()</code> function.</p>

<h3>Advanced</h3>

<p>5) Extend the <code>colSort()</code> function to handle an arbitrary number of columns on
which to do the sorting. You may need to modify the functionality a bit to use
full vectors for the sorting rather than column names.</p>

<p>6) Extend the <code>colSort()</code> function so that it can take either numeric indices or
character strings indicating columns of the input data or take entire vectors to
use in the sorting of the input data. If information specifying columns is
given, make sure your function carefully checks that the input refers to
legitimate columns and returns an error or warning (see <code>warning()</code>) if not.</p>

<p>7) Explore scoping in the following code. Explain why the result is 11 and not 3. Note that <code>funGenerator()</code> returns a function as the return object,
consistent with the idea that functions are objects in R. This is an example of
what is called a <em>closure</em> in R. Basically, the function contains object(s)
enclosed with and accessible to the function.</p>

<pre><code class="r">funGenerator &lt;- function(x) {
   x &lt;- 10
   g &lt;- function(y) {
      return(x + y)
   }
   return(g)
}

x &lt;- 2
f &lt;- funGenerator()
f(1)
</code></pre>

<pre><code>## [1] 11
</code></pre>

</body>

</html>
